<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Financeiro Oficina</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/css/styles.css">
    <!-- Air Datepicker CSS removed (month selector not used) -->
</head>
<body>
    <div class="app-container">
    <!-- Sidebar -->
    <nav class="sidebar">
        <div class="logo">
            <i class="fas fa-chart-line"></i>
            <h1>Financeiro</h1>
        </div>
        
        <ul class="nav-menu">
            <li><a href="#dashboard" class="active" onclick="showSection('dashboard')">
                <i class="fas fa-home"></i> <span>Dashboard</span>
            </a></li>
            <li><a href="#receber" onclick="showSection('receber')">
                <i class="fas fa-money-bill-wave"></i> <span>Contas a Receber</span>
            </a></li>
            <li><a href="#pagar" onclick="showSection('pagar')">
                <i class="fas fa-credit-card"></i> <span>Contas a Pagar</span>
            </a></li>
            <li><a href="#relatorios" onclick="showSection('relatorios')">
                <i class="fas fa-chart-bar"></i> <span>Relatórios</span>
            </a></li>
        </ul>
        
        <div class="sync-status">
            <div class="status-indicator" id="status-indicator"></div>
            <span id="status-text">Offline</span>
            <button class="btn-sync" onclick="syncManager.trySync()">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Top Bar -->
        <!-- top-bar removido (user info) -->

        <!-- Dashboard Section -->
        <div class="dashboard active" id="dashboard-section">
            <h2>Dashboard Financeiro</h2>
            
            <div class="summary-cards">
                <div class="card card-receber">
                    <div class="card-icon">
                        <i class="fas fa-arrow-down"></i>
                    </div>
                    <div class="card-content">
                        <h3>Receber Hoje</h3>
                        <p class="amount" id="receber-hoje">R$ 0,00</p>
                        <span class="trend positive">+0% vs ontem</span>
                    </div>
                </div>
                
                <div class="card card-pagar">
                    <div class="card-icon">
                        <i class="fas fa-arrow-up"></i>
                    </div>
                    <div class="card-content">
                        <h3>Pagar Hoje</h3>
                        <p class="amount" id="pagar-hoje">R$ 0,00</p>
                        <span class="trend negative">-0% vs ontem</span>
                    </div>
                </div>
                
                <div class="card card-saldo">
                    <div class="card-icon">
                        <i class="fas fa-wallet"></i>
                    </div>
                    <div class="card-content">
                        <h3>Saldo do Mês</h3>
                        <p class="amount" id="saldo-mes">R$ 0,00</p>
                        <span class="trend positive">+0% vs último mês</span>
                    </div>
                </div>
                
                <div class="card card-inadimplencia">
                    <div class="card-icon">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div class="card-content">
                        <h3>Inadimplência</h3>
                        <p class="amount" id="inadimplencia">0%</p>
                        <span class="trend positive">-0% vs último mês</span>
                    </div>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="chart-container">
                    <h3>Inadimplência</h3>
                    <canvas id="inadimplencia-chart" style="max-height: 250px;"></canvas>
                </div>
                
                <div class="vencimentos-container">
                    <h3>Vencimentos Hoje</h3>
                    <div class="vencimentos-list" id="vencimentos-hoje">
                        <div class="vencimento-item">
                            <div class="vencimento-info">
                                <h4><span class="badge badge-warning">Aberto</span> Cliente Exemplo</h4>
                                <span>Vencimento: Hoje</span>
                            </div>
                            <div class="vencimento-valor">
                                R$ 1.250,00
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="recent-container">
                    <h3>Últimos Recebimentos</h3>
                    <div class="recent-list" id="ultimos-recebimentos">
                        <!-- Carregado via JS -->
                    </div>
                </div>
                
                <div class="recent-container">
                    <h3>Últimos Pagamentos</h3>
                    <div class="recent-list" id="ultimos-pagamentos">
                        <!-- Carregado via JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Contas a Receber Section -->
        <div class="dashboard hidden" id="receber-section">
            <div class="d-flex justify-between align-center mb-20">
                <h2>Contas a Receber</h2>
                <button class="btn btn-success" onclick="showModal('modal-lancamento-receber')">
                    <i class="fas fa-plus"></i> Novo Recebimento
                </button>
            </div>

            <div class="filters mb-20">
                <div class="form-row">
                    <div class="form-group filter-small">
                        <input type="text" id="filter-cliente" placeholder="Filtrar por cliente...">
                    </div>
                    <div class="form-group filter-small">
                        <select id="filter-mes">
                            <option value="">Mês</option>
                        </select>
                    </div>
                    <div class="form-group filter-small">
                        <select id="filter-ano">
                            <option value="">Ano</option>
                        </select>
                    </div>
                    <div class="form-group filter-small">
                        <select id="filter-status-receber" onchange="filtrarReceber()">
                            <option value="">Todos os status</option>
                            <option value="aberto">Aberto</option>
                            <option value="pago">Pago</option>
                            <option value="atrasado">Atrasado</option>
                            <option value="parcelado">Parcelado</option>
                        </select>
                    </div>
                    <div class="form-group" id="cleanup-btn-container" style="display: none;">
                        <button id="btn-cleanup-financeiro" class="btn btn-danger" onclick="showModal('modal-cleanup-financeiro')">
                            <i class="fas fa-trash-alt"></i> Limpar registros antigos
                        </button>
                    </div>
                </div>
            </div>

            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Cliente</th>
                            <th>Descrição</th>
                            <th>Parcela</th>
                            <th>Valor</th>
                            <th>Vencimento</th>
                            <th>Status</th>
                            <th>Ações</th>
                        </tr>
                    </thead>
                    <tbody id="tabela-receber">
                        <!-- Carregado via JS -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Contas a Pagar Section -->
        <div class="dashboard hidden" id="pagar-section">
            <div class="d-flex justify-between align-center mb-20">
                <h2>Contas a Pagar</h2>
                <div>
                    <button class="btn btn-danger" onclick="showModal('modal-lancamento-pagar')">
                        <i class="fas fa-plus"></i> Novo Pagamento
                    </button>
                </div>
            </div>

            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Fornecedor</th>
                            <th>Descrição</th>
                            <th>Parcela</th>
                            <th>Valor</th>
                            <th>Vencimento</th>
                            <th>Status</th>
                            <th>Ações</th>
                        </tr>
                    </thead>
                    <tbody id="tabela-pagar">
                        <!-- Carregado via JS -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Relatórios Section -->
        <div class="dashboard hidden" id="relatorios-section">
            <h2>Relatórios</h2>
            
            <div class="tabs">
                <div class="tab active" onclick="showTab('rel-duplicatas')">Duplicatas Parceladas</div>
                <div class="tab" onclick="showTab('rel-pagar')">Contas a Pagar</div>
                <div class="tab" onclick="showTab('rel-inadimplencia')">Inadimplência</div>
            </div>

            <div class="tab-content active" id="rel-duplicatas">
                <div class="form-row mb-20">
                    <div class="form-group">
                        <label>Data Início</label>
                        <input type="date" id="rel-data-inicio">
                    </div>
                    <div class="form-group">
                        <label>Data Fim</label>
                        <input type="date" id="rel-data-fim">
                    </div>
                    <div class="form-group">
                        <label>Status</label>
                        <select id="rel-status">
                            <option value="todos">Todos</option>
                            <option value="aberto">Aberto
                                
                            </option>
                            <option value="pago">Pago</option>
                            <option value="atrasado">Atrasado</option>
                            <option value="parcelado">Parcelado</option>
                        </select>
                    </div>
                    <div class="form-group align-center" style="align-self: flex-end;">
                        <button class="btn btn-primary" onclick="gerarRelatorio('duplicatas')">
                            <i class="fas fa-chart-bar"></i> Gerar Relatório
                        </button>
                    </div>
                </div>

                <div class="table-container">
                    <table class="data-table" id="tabela-relatorio">
                        <!-- Carregado via JS -->
                    </table>
                </div>
            </div>

            <div class="tab-content" id="rel-pagar">
                <!-- Conteúdo similar para contas a pagar -->
            </div>

            <div class="tab-content" id="rel-inadimplencia">
                <!-- Conteúdo similar para inadimplência -->
            </div>
                </div>

                <!-- Calendário financeiro removido -->

        </main>
    </div>

    <!-- Modal Limpeza Financeiro -->
    <div id="modal-cleanup-financeiro" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Limpar registros antigos (Financeiro)</h3>
                <button class="modal-close" onclick="hideModal('modal-cleanup-financeiro')">&times;</button>
            </div>
            <div class="modal-body">
                <p>Esta ação fará backup dos registros selecionados e os removerá permanentemente do banco de dados.</p>
                <div class="form-group">
                    <label for="cleanup-before-date">Remover registros com data/vencimento anteriores a:</label>
                    <input type="date" id="cleanup-before-date">
                </div>
                <div class="form-group">
                    <label for="cleanup-admin-pass">Senha administrativa (se configurada)</label>
                    <input type="password" id="cleanup-admin-pass" placeholder="Senha administrativa (opcional)">
                </div>
                <div class="form-group">
                    <label for="cleanup-confirm">Digite <strong>DELETE</strong> para confirmar:</label>
                    <input type="text" id="cleanup-confirm" placeholder="DELETE">
                </div>
                <div class="form-group">
                    <small class="text-muted">Recomendação: faça backup manual do arquivo <code>database.db</code> antes de executar.</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideModal('modal-cleanup-financeiro')">Cancelar</button>
                <button class="btn btn-danger" onclick="executarCleanupFinanceiro()">Executar limpeza segura</button>
            </div>
        </div>
    </div>

    <!-- Modal Admin Login (master) -->
    <div id="modal-admin-login" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Login Master (Admin)</h3>
                <button class="modal-close" onclick="hideModal('modal-admin-login')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="admin-pass-input">Senha administrativa</label>
                    <input type="password" id="admin-pass-input" placeholder="Senha">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideModal('modal-admin-login')">Fechar</button>
                <button class="btn btn-primary" onclick="adminLogin()">Entrar</button>
            </div>
        </div>
    </div>

    <!-- Modal Lançamento Receber -->
    <div id="modal-lancamento-receber" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Lançar Recebimento</h3>
                <button class="modal-close" onclick="hideModal('modal-lancamento-receber')">&times;</button>
            </div>
            <div class="modal-body">
                <form id="form-receber" onsubmit="salvarRecebimento(event)">
                    <div class="form-group" style="position: relative;">
                        <label for="buscar-cliente">Buscar Cliente *</label>
                        <input type="text" id="buscar-cliente" list="clientes-list" 
                               placeholder="Digite o nome do cliente" 
                               oninput="buscarCliente(this.value)"
                               onchange="selecionarClientePorNome(this.value)"
                               autocomplete="off" required>
                        <datalist id="clientes-list"></datalist>
                        <div id="sugestoes-cliente" style="position: absolute; background: white; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; width: calc(100% - 2px); margin-top: 2px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);"></div>
                    </div>
                    
                    <div id="cliente-info" class="hidden">
                        <div class="orcamento-info">
                            <h4>Informações do Cliente</h4>
                            <div class="info-row">
                                <span class="info-label">Nome:</span>
                                <span class="info-value" id="info-cliente-nome"></span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Telefone:</span>
                                <span class="info-value" id="info-cliente-telefone"></span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Veículo:</span>
                                <span class="info-value" id="info-cliente-veiculo"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="orcamento">Orçamentos Aprovados (OS Finalizada) *</label>
                        <select id="orcamento" onchange="carregarDadosOrcamento(this.value)" required>
                            <option value="">Selecione um orçamento...</option>
                        </select>
                    </div>
                    
                    <div id="orcamento-info" class="hidden">
                        <div class="orcamento-info">
                            <h4>Detalhes do Orçamento</h4>
                            <div class="info-row">
                                <span class="info-label">Orçamento #:</span>
                                <span class="info-value" id="info-orcamento-numero"></span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Data:</span>
                                <span class="info-value" id="info-orcamento-data"></span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Serviços:</span>
                                <span class="info-value" id="info-orcamento-servicos"></span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Peças:</span>
                                <span class="info-value" id="info-orcamento-pecas"></span>
                            </div>
                            <div class="info-row total-row">
                                <span class="info-label">Valor Total:</span>
                                <span class="info-value" id="info-orcamento-total"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="tipo-pagamento">Forma de Pagamento *</label>
                        <select id="tipo-pagamento" required onchange="mudarTipoPagamento()">
                            <option value="">Selecione...</option>
                            <option value="avista">À Vista</option>
                            <option value="parcelado">Parcelado</option>
                            <option value="entrada">Entrada + Parcelas</option>
                        </select>
                    </div>
                    
                    <div id="campos-parcelado" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="numero-parcelas">Número de Parcelas</label>
                                <input type="number" id="numero-parcelas" min="2" max="24" value="2" 
                                       onchange="calcularParcelas()">
                            </div>
                            <div class="form-group">
                                <label for="data-primeira-parcela">Data da 1ª Parcela</label>
                                <input type="date" id="data-primeira-parcela" onchange="calcularParcelas()">
                            </div>
                        </div>
                        
                        <div id="tabela-parcelas" class="hidden">
                            <h4>Plano de Parcelas</h4>
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Parcela</th>
                                        <th>Vencimento</th>
                                        <th>Valor</th>
                                    </tr>
                                </thead>
                                <tbody id="lista-parcelas">
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div id="campos-entrada" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="valor-entrada">Valor da Entrada (R$) *</label>
                                <input type="number" id="valor-entrada" step="0.01" min="0" 
                                       placeholder="0,00"
                                       oninput="calcularParcelasEntrada()"
                                       onchange="calcularParcelasEntrada()">
                            </div>
                            <div class="form-group">
                                <label for="numero-parcelas-entrada">Número de Parcelas *</label>
                                <input type="number" id="numero-parcelas-entrada" min="1" max="24" value="1" 
                                       onchange="calcularParcelasEntrada()">
                            </div>
                            <div class="form-group">
                                <label for="data-primeira-parcela-entrada">Data da 1ª Parcela *</label>
                                <input type="date" id="data-primeira-parcela-entrada" onchange="calcularParcelasEntrada()">
                            </div>
                        </div>
                        
                        <div id="tabela-entrada-parcelas" class="hidden">
                            <h4>Plano de Pagamento</h4>
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Tipo</th>
                                        <th>Vencimento</th>
                                        <th>Valor</th>
                                    </tr>
                                </thead>
                                <tbody id="lista-entrada-parcelas">
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="observacoes">Observações</label>
                        <textarea id="observacoes" rows="3"></textarea>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="hideModal('modal-lancamento-receber')">
                            Cancelar
                        </button>
                        <button type="submit" class="btn btn-success">
                            <i class="fas fa-save"></i> Salvar Recebimento
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal Visualizar Duplicata -->
    <div id="modal-visualizar-duplicata" class="modal">
        <div class="modal-content" style="max-width:600px">
            <div class="modal-header">
                <h3>Visualizar Duplicata</h3>
                <button class="modal-close" onclick="hideModal('modal-visualizar-duplicata')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Cliente</label>
                    <div id="vis-dup-cliente" style="font-weight:600"></div>
                </div>
                <div class="form-group">
                    <label>Telefone</label>
                    <div id="vis-dup-telefone"></div>
                </div>
                <div class="form-group">
                    <label>Descrição</label>
                    <div id="vis-dup-descricao"></div>
                </div>
                <div class="form-row">
                    <div class="form-group" style="flex:1">
                        <label>Parcela</label>
                        <div id="vis-dup-parcela"></div>
                    </div>
                    <div class="form-group" style="flex:1">
                        <label>Vencimento</label>
                        <div id="vis-dup-vencimento"></div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group" style="flex:1">
                        <label>Valor</label>
                        <div id="vis-dup-valor"></div>
                    </div>
                    <div class="form-group" style="flex:1">
                        <label>Status</label>
                        <div id="vis-dup-status"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display:flex;gap:8px;justify-content:flex-end">
                <button class="btn btn-secondary" onclick="hideModal('modal-visualizar-duplicata')">Fechar</button>
                <button class="btn btn-whatsapp" onclick="ui.enviarWhatsAppDuplicata(ui.duplicataAtual.id)">Enviar WhatsApp</button>
                <button class="btn btn-success" onclick="ui.marcarComoPago(ui.duplicataAtual.id)">Marcar como pago</button>
                <button class="btn btn-primary" onclick="(function(){ try { whatsappManager.abrirReciboImprimivel(ui.clienteAtual, ui.duplicataAtual); } catch(e){ console.warn(e); } })()">Imprimir / Recibo</button>
            </div>
        </div>
    </div>

    <!-- Modal Lançamento Pagar -->
    <div id="modal-lancamento-pagar" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Lançar Pagamento</h3>
                <button class="modal-close" onclick="hideModal('modal-lancamento-pagar')">&times;</button>
            </div>
            <div class="modal-body">
                <form id="form-pagar" onsubmit="salvarPagamento(event)">
                    <div class="form-group">
                        <label for="fornecedor">Fornecedor *</label>
                        <input type="text" id="fornecedor" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="descricao-pagar">Descrição *</label>
                        <input type="text" id="descricao-pagar" required>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="valor-pagar">Valor *</label>
                            <input type="number" id="valor-pagar" step="0.01" min="0.01" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="vencimento-pagar">Vencimento *</label>
                            <input type="date" id="vencimento-pagar" required>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="tipo-pagar">Tipo</label>
                        <select id="tipo-pagar">
                            <option value="normal">Normal</option>
                            <option value="parcelado">Parcelado</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="observacoes-pagar">Observações</label>
                        <textarea id="observacoes-pagar" rows="3"></textarea>
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="hideModal('modal-lancamento-pagar')">
                            Cancelar
                        </button>
                        <button type="submit" class="btn btn-danger">
                            <i class="fas fa-save"></i> Salvar Pagamento
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal WhatsApp -->
    <div id="modal-whatsapp" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Enviar WhatsApp</h3>
                <button class="modal-close" onclick="hideModal('modal-whatsapp')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="mensagem-whatsapp">Mensagem:</label>
                    <textarea id="mensagem-whatsapp" rows="8"></textarea>
                </div>
                <div class="modal-actions">
                    <button class="btn btn-whatsapp" onclick="abrirWhatsApp()">
                        <i class="fab fa-whatsapp"></i> Abrir WhatsApp
                    </button>
                    <button class="btn btn-secondary" onclick="hideModal('modal-whatsapp')">
                        Cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Banco de Dados - Integrado com index.html via localStorage
        class Database {
            constructor() {
                // Usa localStorage compartilhado com index.html
                this.storageKeys = {
                    clientes: 'clientes',
                    orcamentos: 'orcamentos',
                    ordensServico: 'ordensServico',
                    receber: 'financeiro-receber',
                    pagar: 'financeiro-pagar',
                    syncQueue: 'financeiro-sync-queue'
                };
            }
            
            // Função auxiliar para normalizar IDs (pode ser string ou number)
            normalizarId(id) {
                if (id == null || id === undefined || id === '') return null;
                return String(id);
            }
            
            // Função auxiliar para comparar IDs
            idsIguais(id1, id2) {
                if (id1 == null || id2 == null) return false;
                return this.normalizarId(id1) === this.normalizarId(id2);
            }

            async init() {
                // Inicializar arrays vazios se não existirem (localStorage compartilhado com index.html)
                if (!localStorage.getItem(this.storageKeys.receber)) {
                    localStorage.setItem(this.storageKeys.receber, JSON.stringify([]));
                }
                if (!localStorage.getItem(this.storageKeys.pagar)) {
                    localStorage.setItem(this.storageKeys.pagar, JSON.stringify([]));
                }
                
                // Sincronizar dados do servidor se online
                if (navigator.onLine) {
                    try {
                        console.log('Iniciando sincronização com servidor...');
                        const response = await fetch('/api/financeiro');
                        if (response.ok) {
                            const dados = await response.json();
                            console.log('Dados sincronizados do servidor:', dados);
                            
                            // Separar por tipo
                            const receber = dados.filter(d => d.tipo === 'receber').map(d => ({
                                ...d,
                                id: String(d.id)
                            }));
                            const pagar = dados.filter(d => d.tipo === 'pagar').map(d => ({
                                ...d,
                                id: String(d.id)
                            }));
                            
                            console.log(`Recebimentos do servidor: ${receber.length}, Pagamentos: ${pagar.length}`);
                            
                            // Mesclar com dados locais existentes para não perder lançamentos não sincronizados
                            try {
                                const locaisReceber = this.getAllSync('receber');
                                const locaisPagar = this.getAllSync('pagar');

                                // Map de IDs do servidor para fácil verificação
                                const idsReceberServer = new Set(receber.map(r => String(r.id)));
                                const idsPagarServer = new Set(pagar.map(p => String(p.id)));

                                // Incluir itens locais que não existem no servidor
                                locaisReceber.forEach(item => {
                                    if (!idsReceberServer.has(String(item.id))) {
                                        receber.push(item);
                                    }
                                });
                                locaisPagar.forEach(item => {
                                    if (!idsPagarServer.has(String(item.id))) {
                                        pagar.push(item);
                                    }
                                });

                                localStorage.setItem(this.storageKeys.receber, JSON.stringify(receber));
                                localStorage.setItem(this.storageKeys.pagar, JSON.stringify(pagar));
                                console.log('Dados sincronizados (mesclados) com sucesso no localStorage');
                            } catch (mergeErr) {
                                console.warn('Erro ao mesclar dados locais com servidor, sobrescrevendo localStorage:', mergeErr);
                                localStorage.setItem(this.storageKeys.receber, JSON.stringify(receber));
                                localStorage.setItem(this.storageKeys.pagar, JSON.stringify(pagar));
                            }
                        } else {
                            console.warn('Erro ao sincronizar dados do servidor:', response.status, response.statusText);
                        }
                    } catch (error) {
                        console.warn('Erro ao sincronizar dados do servidor:', error);
                    }
                } else {
                    console.log('Offline - usando dados locais do localStorage');
                }
                
                console.log('Banco de dados inicializado (localStorage com sincronização do servidor)');
                return Promise.resolve();
            }

            // Métodos para receber e pagar (sincronizados com servidor)
            async add(store, data) {
                const key = this.storageKeys[store];
                if (!key) throw new Error(`Store ${store} não encontrado`);
                
                // Se for receber ou pagar, sincronizar com servidor
                if (store === 'receber' || store === 'pagar') {
                    const endpoint = '/api/financeiro';
                    // Garantir que o campo `tipo` enviado ao servidor seja sempre o `store`
                    const body = { ...data, tipo: store };

                    // Normalizações simples para evitar 400 por formato
                    if (body.valor !== undefined) {
                        // Converter para Number suportando formatos: "100,00", "1.234,56", "R$ 1.234,56"
                        (function() {
                            try {
                                let s = String(body.valor).trim();
                                s = s.replace(/\s/g, '');
                                s = s.replace(/R\$|r\$/g, '');
                                if (s.indexOf('.') !== -1 && s.indexOf(',') !== -1) {
                                    s = s.replace(/\./g, '');
                                    s = s.replace(/,/g, '.');
                                } else {
                                    if (s.indexOf(',') !== -1) s = s.replace(/,/g, '.');
                                }
                                s = s.replace(/[^0-9.-]/g, '');
                                const n = Number(s);
                                body.valor = Number.isNaN(n) ? 0 : n;
                            } catch (e) {
                                body.valor = Number(body.valor) || 0;
                            }
                        })();
                    }
                    // Garantir que exista vencimento — usar `data` como fallback
                    if (!body.vencimento) {
                        body.vencimento = body.data || new Date().toISOString().split('T')[0];
                    }
                    
                    // Capturar id local antes do POST para possibilitar substituição posterior
                    const originalLocalId = data.id ? String(data.id) : null;

                    // Sempre tentar enviar ao servidor local primeiro (servidor local pode estar acessível mesmo sem conexao à internet).
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(body)
                        });

                        if (response.ok) {
                            const resultado = await response.json();
                            if (resultado && resultado.id) {
                                const serverId = String(resultado.id);
                                data.id = serverId;
                                // Se o id local anterior for diferente do id do servidor, substituir localmente
                                if (originalLocalId && originalLocalId !== serverId) {
                                    try {
                                        await this.replaceIdAcrossStores(originalLocalId, serverId);
                                        console.log(`Substituído id local ${originalLocalId} por id do servidor ${serverId} em storage`);
                                    } catch (repErr) {
                                        console.warn('Erro ao substituir ids locais após POST:', repErr);
                                    }
                                }
                            }
                            console.log(`${store} salvo no servidor com ID: ${data.id}`);
                        } else if (response.status === 409) {
                            const erro = await response.json();
                            throw new Error(erro.error || 'Conflito 409');
                        } else {
                            console.warn('Erro ao salvar no servidor (status não-ok), enfileirando para retry');
                            try {
                                this.enqueueSync(store, body, originalLocalId || data.id);
                            } catch (e) {
                                console.warn('Falha ao enfileirar item após erro de POST:', e);
                            }
                        }
                    } catch (error) {
                        // Falha de rede ao tentar alcançar o servidor local — enfileirar para retry
                        console.warn(`Erro ao sincronizar ${store} (fetch falhou):`, error);
                        try {
                            this.enqueueSync(store, body, originalLocalId || data.id);
                        } catch (e) {
                            console.warn('Falha ao enfileirar item após exception de POST:', e);
                        }
                    }
                }
                
                // Salvar localmente (sempre)
                const items = this.getAllSync(store);
                items.push(data);
                localStorage.setItem(key, JSON.stringify(items));
                return Promise.resolve(data.id);
            }

            // Substitui ocorrências do id antigo pelo novo em todos os storageKeys
            async replaceIdAcrossStores(oldId, newId) {
                if (!oldId || !newId) return Promise.resolve();
                try {
                    const keys = Object.values(this.storageKeys);

                    const replaceInObject = (obj) => {
                        if (!obj || typeof obj !== 'object') return false;
                        let changed = false;

                        const walk = (value, parent, k) => {
                            if (value === null || value === undefined) return;
                            if (typeof value === 'string' || typeof value === 'number') {
                                if (String(value) === String(oldId)) {
                                    parent[k] = String(newId);
                                    changed = true;
                                }
                                return;
                            }
                            if (Array.isArray(value)) {
                                for (let i = 0; i < value.length; i++) {
                                    walk(value[i], value, i);
                                }
                                return;
                            }
                            if (typeof value === 'object') {
                                Object.keys(value).forEach(kk => walk(value[kk], value, kk));
                                return;
                            }
                        };

                        Object.keys(obj).forEach(k => walk(obj[k], obj, k));
                        return changed;
                    };

                    for (const k of keys) {
                        try {
                            const raw = localStorage.getItem(k);
                            if (!raw) continue;
                            let arr = JSON.parse(raw);
                            let changedAny = false;
                            if (Array.isArray(arr)) {
                                for (let i = 0; i < arr.length; i++) {
                                    const it = arr[i];
                                    try {
                                        const changed = replaceInObject(it);
                                        if (changed) changedAny = true;
                                    } catch (e) {
                                        // ignore element parse errors
                                    }
                                }
                            } else if (typeof arr === 'object') {
                                if (replaceInObject(arr)) changedAny = true;
                            }
                            if (changedAny) {
                                localStorage.setItem(k, JSON.stringify(arr));
                            }
                        } catch (e) {
                            // ignorar erros de parsing em keys que não sejam arrays
                        }
                    }
                } catch (e) {
                    console.warn('replaceIdAcrossStores falhou:', e);
                }
                return Promise.resolve();
            }

            // --- Sync Queue helpers ---
            _getSyncQueue() {
                try {
                    const raw = localStorage.getItem(this.storageKeys.syncQueue);
                    if (!raw) return [];
                    return JSON.parse(raw);
                } catch (e) {
                    return [];
                }
            }

            _setSyncQueue(arr) {
                try {
                    localStorage.setItem(this.storageKeys.syncQueue, JSON.stringify(arr || []));
                } catch (e) {
                    console.warn('Falha ao salvar syncQueue:', e);
                }
            }

            enqueueSync(store, item, originalLocalId = null) {
                try {
                    // garantir que o item contenha o tipo correto
                    if (item && !item.tipo) item.tipo = store;
                    const queue = this._getSyncQueue();
                    const qItem = {
                        id: (Date.now()).toString() + Math.random().toString(36).substr(2,6),
                        store,
                        item,
                        originalLocalId: originalLocalId ? String(originalLocalId) : (item && item.id ? String(item.id) : null),
                        attempts: 0,
                        createdAt: new Date().toISOString(),
                        lastAttemptAt: null
                    };
                    queue.push(qItem);
                    this._setSyncQueue(queue);
                    console.log('Enfileirado para sync:', qItem.id, store, qItem.originalLocalId);
                    return qItem.id;
                } catch (e) {
                    console.warn('Falha ao enfileirar sync:', e);
                    return null;
                }
            }

            removeFromSyncQueueById(queueId) {
                try {
                    let queue = this._getSyncQueue();
                    const before = queue.length;
                    queue = queue.filter(q => String(q.id) !== String(queueId));
                    this._setSyncQueue(queue);
                    console.log(`SyncQueue: removido ${queueId} (${before} → ${queue.length})`);
                } catch (e) {
                    console.warn('Falha ao remover item da syncQueue:', e);
                }
            }

            async put(store, data) {
                const key = this.storageKeys[store];
                if (!key) throw new Error(`Store ${store} não encontrado`);
                
                // Se for receber ou pagar, sincronizar com servidor
                if ((store === 'receber' || store === 'pagar') && data.id) {
                    const id = data.id;
                    const endpoint = `/api/financeiro/${id}`;
                    const body = { tipo: store, ...data };
                    
                    // Só tentar PUT no servidor se o id for numérico (server id). Se for id temporário, enfileirar para POST posteriormente.
                    const isNumericId = String(id).match(/^\d+$/);
                    if (navigator.onLine && isNumericId) {
                        try {
                            const response = await fetch(endpoint, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(body)
                            });

                            if (response.ok) {
                                console.log(`${store} atualizado no servidor com ID: ${id}`);
                            } else {
                                const text = await response.text().catch(() => null);
                                console.warn('Erro ao atualizar no servidor, atualizando localmente', response.status, text);
                                // Enfileirar para retry caso o servidor não aceite o PUT
                                try { this.enqueueSync(store, body, id); } catch (e) { console.warn('Falha ao enfileirar item após PUT falho:', e); }
                            }
                        } catch (error) {
                            console.warn(`Erro ao sincronizar ${store}:`, error);
                            try { this.enqueueSync(store, body, id); } catch (e) { console.warn('Falha ao enfileirar item após exception de PUT:', e); }
                        }
                    } else if (!isNumericId) {
                        // id local temporário: enfileirar para criação/atualização no servidor
                        try { this.enqueueSync(store, body, id); } catch (e) { console.warn('Falha ao enfileirar item com id não-numérico:', e); }
                    }
                }
                
                // Salvar localmente no localStorage
                const items = this.getAllSync(store);
                const index = items.findIndex(item => String(item.id) === String(data.id));
                if (index >= 0) {
                    items[index] = data;
                } else {
                    items.push(data);
                }
                localStorage.setItem(key, JSON.stringify(items));
                return Promise.resolve(data.id);
            }

            async get(store, key) {
                if (store === 'clientes' || store === 'orcamentos' || store === 'ordensServico') {
                    // Buscar nos dados compartilhados do index.html
                    const items = this.getAllSync(store);
                    return Promise.resolve(items.find(item => item.id == key || item.id === key));
                }
                
                const items = this.getAllSync(store);
                return Promise.resolve(items.find(item => item.id == key || item.id === key));
            }

            getAllSync(store) {
                const key = this.storageKeys[store];
                if (!key) return [];
                
                try {
                    const stored = localStorage.getItem(key);
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.error(`Erro ao ler ${store} do localStorage:`, error);
                    return [];
                }
            }

            async getAll(store, index = null, value = null) {
                let items = this.getAllSync(store);
                
                // Filtrar por índice se fornecido
                if (index && value !== null) {
                    items = items.filter(item => {
                        if (index === 'vencimento') {
                            return item.vencimento === value;
                        }
                        return item[index] === value;
                    });
                }
                
                return Promise.resolve(items);
            }

            async delete(store, key) {
                // Se for receber ou pagar, sincronizar com servidor
                if ((store === 'receber' || store === 'pagar') && key) {
                    // Heurística para detectar se é ID do servidor ou ID local:
                    // IDs do servidor (SQLite AUTOINCREMENT): 1-7 dígitos (até ~9 milhões)
                    // IDs locais (Date.now + rand): 14+ dígitos ou contém caracteres não-dígitos
                    const keyStr = String(key);
                    const onlyDigits = /^\d+$/.test(keyStr);
                    const isServerLike = onlyDigits && keyStr.length <= 7;
                    
                    console.log(`[DELETE] store=${store}, key=${keyStr}, onlyDigits=${onlyDigits}, length=${keyStr.length}, isServerLike=${isServerLike}`);
                    
                    if (!isServerLike) {
                        console.warn(`[DELETE] ID '${keyStr}' detectado como ID local (não sincronizado com servidor); deletando apenas localmente`);
                    } else {
                        const endpoint = `/api/financeiro/${keyStr}`;
                        if (navigator.onLine) {
                            try {
                                console.log(`[DELETE] Chamando DELETE remoto para ${endpoint}`);
                                const response = await fetch(endpoint, { method: 'DELETE' });
                                if (response.ok) {
                                    try {
                                        const respJson = await response.json();
                                        console.log(`[DELETE] Resposta do servidor:`, respJson);
                                        // servidor pode retornar { tipo, deletedId, removed }
                                        if (respJson && respJson.tipo) {
                                            const tipo = String(respJson.tipo).toLowerCase();
                                            if (tipo === 'receber') {
                                                // já removido remotamente — garantir remoção local no store correto
                                                await ui.db.delete('receber', keyStr);
                                            } else if (tipo === 'pagar') {
                                                await ui.db.delete('pagar', keyStr);
                                            } else {
                                                // tipo desconhecido — limpar em ambos apenas por segurança
                                                await ui.db.delete('receber', keyStr);
                                                await ui.db.delete('pagar', keyStr);
                                            }
                                        } else if (respJson && respJson.deletedId) {
                                            // compatibilidade com formato antigo
                                            await ui.db.delete('receber', respJson.deletedId);
                                            await ui.db.delete('pagar', respJson.deletedId);
                                        } else {
                                            console.log(`${store} deletado do servidor com ID: ${keyStr}`);
                                        }
                                    } catch (e) {
                                        console.log(`${store} deletado do servidor com ID: ${keyStr}`);
                                    }
                                } else {
                                    try {
                                        const txt = await response.text();
                                        console.warn(`[DELETE] Erro ${response.status} ao deletar do servidor: ${txt}, deletando localmente`, response.status, txt);
                                    } catch (e) {
                                        console.warn(`[DELETE] Erro ${response.status} ao deletar do servidor, deletando localmente`);
                                    }
                                }
                            } catch (error) {
                                console.warn(`[DELETE] Erro ao sincronizar ${store}:`, error);
                            }
                        } else {
                            console.log(`[DELETE] Offline; deletando apenas localmente`);
                        }
                    }
                }
                
                // Deletar localmente (sempre)
                const items = this.getAllSync(store);
                const filtered = items.filter(item => String(item.id) !== String(key));
                const storageKey = this.storageKeys[store];
                localStorage.setItem(storageKey, JSON.stringify(filtered));
                console.log(`[DELETE] Removido localmente: ${store} ID ${key} (${items.length} → ${filtered.length} itens)`);
                return Promise.resolve();
            }

            // Métodos específicos
            async gerarId() {
                return Date.now().toString() + Math.random().toString(36).substr(2, 9);
            }

            async getTotalReceberHoje() {
                const hoje = new Date().toISOString().split('T')[0];
                const receber = await this.getAll('receber', 'vencimento', hoje);
                return receber
                    .filter(r => r.status === 'aberto')
                    .reduce((total, r) => total + (r.valor || 0), 0);
            }

            async getTotalPagarHoje() {
                const hoje = new Date().toISOString().split('T')[0];
                const pagar = await this.getAll('pagar', 'vencimento', hoje);
                return pagar
                    .filter(p => p.status === 'aberto')
                    .reduce((total, p) => total + (p.valor || 0), 0);
            }

            async getVencimentosHoje() {
                const hoje = new Date().toISOString().split('T')[0];
                const receber = await this.getAll('receber', 'vencimento', hoje);
                const pagar = await this.getAll('pagar', 'vencimento', hoje);
                
                return {
                    receber: receber.filter(r => r.status === 'aberto'),
                    pagar: pagar.filter(p => p.status === 'aberto')
                };
            }

            async getUltimosRecebimentos() {
                const receber = await this.getAll('receber');
                return receber
                    .filter(r => r.status === 'pago')
                    .sort((a, b) => new Date(b.dataPagamento || 0) - new Date(a.dataPagamento || 0))
                    .slice(0, 5);
            }

            async getUltimosPagamentos() {
                const pagar = await this.getAll('pagar');
                return pagar
                    .filter(p => p.status === 'pago')
                    .sort((a, b) => new Date(b.dataPagamento || 0) - new Date(a.dataPagamento || 0))
                    .slice(0, 5);
            }

            async getFluxoCaixa7Dias() {
                const hoje = new Date();
                const fluxo = [];
                
                for (let i = 0; i < 7; i++) {
                    const data = new Date(hoje);
                    data.setDate(hoje.getDate() + i);
                    const dataStr = data.toISOString().split('T')[0];
                    
                    const receber = await this.getAll('receber', 'vencimento', dataStr);
                    const pagar = await this.getAll('pagar', 'vencimento', dataStr);
                    
                    const totalReceber = receber
                        .filter(r => r.status === 'aberto')
                        .reduce((sum, r) => sum + (r.valor || 0), 0);
                        
                    const totalPagar = pagar
                        .filter(p => p.status === 'aberto')
                        .reduce((sum, p) => sum + (p.valor || 0), 0);
                    
                    fluxo.push({
                        data: dataStr,
                        receber: totalReceber,
                        pagar: totalPagar,
                        saldo: totalReceber - totalPagar
                    });
                }
                
                return fluxo;
            }

            async buscarClientesPorNome(nome) {
                // Buscar clientes do localStorage compartilhado com index.html
                const clientes = this.getAllSync('clientes');
                console.log('Total de clientes no localStorage:', clientes.length);
                
                if (!nome) return Promise.resolve(clientes);
                
                const clientesFiltrados = clientes.filter(cliente => 
                    cliente.nome && cliente.nome.toLowerCase().includes(nome.toLowerCase())
                );
                
                console.log('Clientes encontrados para:', nome, 'Total:', clientesFiltrados.length);
                
                return Promise.resolve(clientesFiltrados);
            }

            async getOrcamentosAprovadosPorCliente(clienteId) {
                // Forçar recarregamento dos dados do localStorage (pode ter sido atualizado no index.html)
                const orcamentosRaw = localStorage.getItem('orcamentos');
                const ordensServicoRaw = localStorage.getItem('ordensServico');
                
                let orcamentos = [];
                let ordensServico = [];
                
                try {
                    orcamentos = orcamentosRaw ? JSON.parse(orcamentosRaw) : [];
                    ordensServico = ordensServicoRaw ? JSON.parse(ordensServicoRaw) : [];
                } catch (error) {
                    console.error('Erro ao parsear dados do localStorage:', error);
                    return Promise.resolve([]);
                }
                
                // Normalizar clienteId para comparação
                const clienteIdNormalizado = this.normalizarId(clienteId);
                
                console.log('=== BUSCA DE ORÇAMENTOS ===');
                console.log('Cliente ID:', clienteId, 'Normalizado:', clienteIdNormalizado);
                console.log('Total de orçamentos no localStorage:', orcamentos.length);
                console.log('Total de OS no localStorage:', ordensServico.length);
                
                // Debug: mostrar todos os orçamentos
                console.log('Todos os orçamentos:', orcamentos.map(o => ({
                    id: o.id,
                    numero: o.numero,
                    clienteId: o.clienteId || o.cliente_id,
                    status: o.status
                })));
                
                // Debug: mostrar todas as OS
                console.log('Todas as OS:', ordensServico.map(os => ({
                    id: os.id,
                    numero: os.numero,
                    orcamentoId: os.orcamentoId || os.orcamento_id,
                    status: os.status
                })));
                
                if (orcamentos.length === 0) {
                    console.warn('⚠️ Nenhum orçamento encontrado no localStorage!');
                    return Promise.resolve([]);
                }
                
                // Filtrar orçamentos aprovados e finalizados do cliente
                // Verificar tanto clienteId quanto cliente_id (formato do servidor)
                const orcamentosAprovadosEFinalizados = orcamentos.filter(orcamento => {
                    const orcClienteId = this.normalizarId(orcamento.clienteId);
                    const orcClienteIdAlt = this.normalizarId(orcamento.cliente_id);
                    // Aceitar orçamentos aprovados OU finalizados
                    const statusOk = orcamento.status === 'aprovado' || orcamento.status === 'finalizado';
                    const clienteOk = this.idsIguais(orcClienteId, clienteIdNormalizado) || 
                                     this.idsIguais(orcClienteIdAlt, clienteIdNormalizado);
                    
                    if (clienteOk) {
                        console.log('Orçamento do cliente encontrado:', {
                            id: orcamento.id,
                            numero: orcamento.numero,
                            clienteId: orcamento.clienteId || orcamento.cliente_id,
                            status: orcamento.status,
                            statusOk: statusOk
                        });
                    }
                    
                    return clienteOk && statusOk;
                });
                
                console.log('✅ Orçamentos aprovados e finalizados encontrados:', orcamentosAprovadosEFinalizados.length);
                
                if (orcamentosAprovadosEFinalizados.length === 0) {
                    console.warn('⚠️ Nenhum orçamento aprovado ou finalizado encontrado para este cliente');
                    return Promise.resolve([]);
                }
                
                console.log('=== FIM DA BUSCA ===');
                
                return Promise.resolve(orcamentosAprovadosEFinalizados);
            }

            async getOrcamentoCompleto(orcamentoId) {
                const orcamentos = this.getAllSync('orcamentos');
                const orcamento = orcamentos.find(o => o.id == orcamentoId || o.id === orcamentoId);
                
                if (!orcamento) return Promise.resolve(null);
                
                // Calcular valores se não existirem
                if (!orcamento.valorTotal && orcamento.total) {
                    orcamento.valorTotal = orcamento.total;
                }
                
                // Buscar serviços e peças
                if (orcamento.servicos && typeof orcamento.servicos === 'string') {
                    try {
                        orcamento.servicos = JSON.parse(orcamento.servicos);
                    } catch (e) {
                        orcamento.servicos = [];
                    }
                }
                
                if (orcamento.pecas && typeof orcamento.pecas === 'string') {
                    try {
                        orcamento.pecas = JSON.parse(orcamento.pecas);
                    } catch (e) {
                        orcamento.pecas = [];
                    }
                }
                
                // Calcular totais se necessário
                if (!orcamento.valorTotal) {
                    const valorServicos = Array.isArray(orcamento.servicos) 
                        ? orcamento.servicos.reduce((sum, s) => sum + (parseFloat(s.valor) || 0), 0)
                        : 0;
                    const valorPecas = Array.isArray(orcamento.pecas)
                        ? orcamento.pecas.reduce((sum, p) => sum + (parseFloat(p.valor) || 0), 0)
                        : 0;
                    const desconto = parseFloat(orcamento.desconto) || 0;
                    orcamento.valorTotal = valorServicos + valorPecas - desconto;
                }
                
                return Promise.resolve(orcamento);
            }
        }

        // Sync Manager
        class SyncManager {
            constructor() {
                this.isOnline = navigator.onLine;
                this.updateStatus();
            }

            updateStatus() {
                const indicator = document.getElementById('status-indicator');
                const text = document.getElementById('status-text');
                
                if (this.isOnline) {
                    indicator.className = 'status-indicator';
                    text.textContent = 'Online';
                } else {
                    indicator.className = 'status-indicator offline';
                    text.textContent = 'Offline';
                }
            }

            async trySync() {
                if (!this.isOnline) {
                    showToast('Você está offline. Sincronização adiada.', 'warning');
                    return;
                }

                showToast('Sincronizando fila...', 'info');
                try {
                    if (!window.ui) {
                        console.warn('UI não inicializado para sincronização');
                        showToast('UI não inicializado para sync', 'warning');
                        return;
                    }

                    let db = window.ui.db;
                    if (!db) {
                        console.warn('DB não inicializado — tentando inicializar antes de sync');
                        showToast('Banco não pronto para sync — inicializando...', 'info');
                        if (typeof window.ui.init === 'function') {
                            try {
                                await window.ui.init();
                                db = window.ui.db;
                            } catch (e) {
                                console.warn('Falha ao inicializar DB para sincronização:', e);
                                showToast('Falha ao inicializar DB para sync', 'error');
                                return;
                            }
                        } else {
                            showToast('Banco não disponível para sincronização', 'error');
                            return;
                        }
                    }
                    let qArr = db._getSyncQueue();
                    if (!qArr || qArr.length === 0) {
                        // fallback: recarregar dados do servidor
                        if (typeof db.init === 'function') await db.init();
                        showToast('Sincronização concluída (nada na fila).', 'success');
                        return;
                    }

                    const MAX_ATTEMPTS = 6; // limite de tentativas
                    for (let i = 0; i < qArr.length; ) {
                        const q = qArr[i];
                        try {
                            // backoff: calcular delay com base em attempts
                            const attempts = q.attempts || 0;
                            if (attempts >= MAX_ATTEMPTS) {
                                console.warn(`Fila: ${q.id} excedeu máximo de tentativas (${attempts}), removendo.`);
                                qArr.splice(i, 1);
                                db._setSyncQueue(qArr);
                                continue; // não incrementar i
                            }

                            const last = q.lastAttemptAt ? new Date(q.lastAttemptAt).getTime() : 0;
                            const delayMs = Math.min(Math.pow(2, attempts) * 1000, 5 * 60 * 1000); // cap 5min
                            if (last && (Date.now() - last) < delayMs) {
                                // ainda no backoff, pular por enquanto
                                i++;
                                continue;
                            }

                            if (!navigator.onLine) throw new Error('offline');
                            console.log('Fila: tentando reenviar item:', q.id, q.store, q.originalLocalId, 'attempts=', attempts);

                            // garantir id e tipo no item da fila (compatibilidade com filas antigas)
                            if (!q.id) q.id = (Date.now()).toString() + Math.random().toString(36).substr(2,6);
                            if (!q.item) q.item = {};
                            if (!q.item.tipo) q.item.tipo = q.store;

                            // Validações: para receber/pagar, garantir valor > 0 e vencimento
                            try {
                                const tipoLow = String(q.item.tipo || '').toLowerCase();
                                if (tipoLow === 'receber' || tipoLow === 'pagar') {
                                    // normalizar e validar valor
                                    let vv = q.item.valor;
                                    if (typeof vv === 'string') {
                                        let s = vv.replace(/\s/g,'');
                                        s = s.replace(/R\$|r\$/g,'');
                                        if (s.indexOf('.') !== -1 && s.indexOf(',') !== -1) { s = s.replace(/\./g,''); s = s.replace(/,/g,'.'); }
                                        else if (s.indexOf(',') !== -1) { s = s.replace(/,/g,'.'); }
                                        s = s.replace(/[^0-9.-]/g,'');
                                        vv = Number(s);
                                    }
                                    vv = Number(vv);
                                    if (!vv || Number.isNaN(vv) || vv <= 0) {
                                        console.warn(`Fila: item ${q.id} com valor inválido (${q.item.valor}), movendo para fila de falhas.`);
                                        const failedKey = 'financeiro-sync-queue-failed';
                                        const failedArr = JSON.parse(localStorage.getItem(failedKey) || '[]');
                                        failedArr.push(Object.assign({ movedAt: new Date().toISOString(), reason: 'valor-invalido' }, q));
                                        localStorage.setItem(failedKey, JSON.stringify(failedArr));
                                        qArr.splice(i, 1);
                                        db._setSyncQueue(qArr);
                                        continue;
                                    }
                                    q.item.valor = vv;
                                    if (!q.item.vencimento) q.item.vencimento = q.item.data || new Date().toISOString().split('T')[0];
                                }
                            } catch (valErr) {
                                console.warn('Erro ao validar item da fila antes do POST:', valErr);
                            }

                            // atualizar lastAttemptAt antes de tentar
                            q.lastAttemptAt = new Date().toISOString();
                            db._setSyncQueue(qArr);

                            const response = await fetch('/api/financeiro', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(q.item)
                            });

                            if (response.ok) {
                                const resultado = await response.json();
                                if (resultado && resultado.id) {
                                    const serverId = String(resultado.id);
                                    if (q.originalLocalId && q.originalLocalId !== serverId) {
                                        try {
                                            await db.replaceIdAcrossStores(q.originalLocalId, serverId);
                                            console.log(`Fila: substituído ${q.originalLocalId} → ${serverId}`);
                                        } catch (repErr) {
                                            console.warn('Fila: erro ao substituir ids:', repErr);
                                        }
                                    }
                                }
                                // remover do queue
                                qArr = db._getSyncQueue();
                                const idxNow = qArr.findIndex(x => String(x.id) === String(q.id));
                                if (idxNow >= 0) {
                                    qArr.splice(idxNow, 1);
                                    db._setSyncQueue(qArr);
                                }
                                // don't increment i because qArr updated; reload queue length
                                qArr = db._getSyncQueue();
                                continue;
                            } else {
                                const parsedText = await response.text().catch(() => null);
                                let parsed = null;
                                try { parsed = parsedText ? JSON.parse(parsedText) : null; } catch(e){ parsed = null; }
                                console.warn('Fila: POST retornou erro', response.status, parsed || parsedText);

                                // Se for conflito (409), provavelmente já existe no servidor — remover do queue
                                if (response.status === 409) {
                                    console.warn(`Fila: item ${q.id} conflitou no servidor, removendo da fila.`);
                                    qArr = db._getSyncQueue();
                                    const idxNow = qArr.findIndex(x => String(x.id) === String(q.id));
                                    if (idxNow >= 0) { qArr.splice(idxNow, 1); db._setSyncQueue(qArr); }
                                    // forçar recarregamento do servidor ao final
                                    i = 0; // continue loop with updated queue
                                    continue;
                                }

                                // Erro 400 indicando tipo ausente/errado: tentar corrigir adicionando tipo e re-enfileirar
                                if (response.status === 400 && parsed && parsed.error && parsed.error.toLowerCase().includes('tipo')) {
                                    console.warn('Fila: resposta 400 sobre tipo — corrigindo tipo e re-enfileirando.');
                                    q.item.tipo = q.store;
                                    q.attempts = (q.attempts || 0) + 1;
                                    q.lastAttemptAt = new Date().toISOString();
                                    db._setSyncQueue(qArr);
                                    i++;
                                    continue;
                                }

                                // incrementar attempts
                                q.attempts = (q.attempts || 0) + 1;
                                q.lastAttemptAt = new Date().toISOString();
                                db._setSyncQueue(qArr);
                                i++;
                            }
                        } catch (e) {
                            console.warn('Fila: erro ao reenviar item:', q.id, e);
                            // incrementar attempts e atualizar lastAttemptAt
                            q.attempts = (q.attempts || 0) + 1;
                            q.lastAttemptAt = new Date().toISOString();
                            db._setSyncQueue(qArr);
                            i++;
                        }
                    }

                    // Ao final, forçar recarregamento do servidor para mesclar
                    if (typeof db.init === 'function') await db.init();
                    showToast('Sincronização da fila concluída.', 'success');
                } catch (err) {
                    console.warn('Erro durante sincronização manual:', err);
                    showToast('Erro durante sincronização', 'error');
                }
            }
        }

        // WhatsApp Manager
        class WhatsAppManager {
            getSaudacao() {
                const hora = new Date().getHours();
                if (hora >= 5 && hora < 12) return 'Bom dia';
                if (hora >= 12 && hora < 18) return 'Boa tarde';
                if (hora >= 18 && hora <= 23) return 'Boa noite';
                return 'Olá';
            }

            formatarTelefone(telefone) {
                if (!telefone) return '';
                return telefone.replace(/\D/g, '');
            }

            // Retorna o primeiro número de telefone válido encontrado no objeto cliente
            obterTelefoneCliente(cliente) {
                if (!cliente || typeof cliente !== 'object') return '';
                const candidates = [
                    cliente.telefone,
                    cliente.whatsapp,
                    cliente.numero,
                    cliente.numeroTelefone,
                    cliente.telefone_celular,
                    cliente.phone,
                    cliente.mobile,
                    cliente.celular
                ];
                for (const c of candidates) {
                    if (c) {
                        const cleaned = String(c).replace(/\D/g, '');
                        if (cleaned.length >= 8) return cleaned; // mínimo razoável
                    }
                }
                // também tentar varrer propriedades dinamicamente por chave
                for (const k of Object.keys(cliente)) {
                    if (/tel|phone|cel|whats?/i.test(k)) {
                        const v = cliente[k];
                        if (v) {
                            const cleaned = String(v).replace(/\D/g, '');
                            if (cleaned.length >= 8) return cleaned;
                        }
                    }
                }
                return '';
            }

            formatarDataBR(dataISO) {
                if (!dataISO) return '';
                const [ano, mes, dia] = dataISO.split('-');
                return `${dia}/${mes}/${ano}`;
            }

            gerarMensagem(cliente, duplicata) {
                const saudacao = this.getSaudacao();
                const nomeCliente = (cliente && cliente.nome) ? cliente.nome.split(' ')[0] : (duplicata.cliente || 'Cliente');
                const venc = duplicata.vencimento ? this.formatarDataBR(duplicata.vencimento) : '---';
                const valor = duplicata.valor != null ? Number(duplicata.valor).toFixed(2) : '0.00';
                const statusOrc = (duplicata.status === 'pago') ? 'pago' : 'em aberto';

                const numeroOrc = duplicata.numeroDuplicata || duplicata.numero_duplicata || duplicata.numero || 0;
                return `${saudacao}, ${nomeCliente}! Tudo bem?\nAqui é da Oficina Mecânica Nego Car.\nPassando para informar sobre a duplicata referente a: Orçamento ${numeroOrc}, que se encontra em ${statusOrc}, em nosso sistema\n\n📌 Parcela: ${duplicata.parcela || ''}\n📅 Vencimento: ${venc}\n💰 Valor: R$ ${valor}\n\nSe já realizou o pagamento, por favor nos avise.\n\nObrigado!`;
            }

            // Gera link web (wa.me) — usado apenas como fallback ou visualização
            gerarLinkWeb(telefone, mensagem) {
                const tel = this.formatarTelefone(telefone);
                const msg = encodeURIComponent(mensagem);
                return `https://wa.me/55${tel}?text=${msg}`;
            }

            // Gera link para abrir o aplicativo nativo (scheme)
            gerarLinkApp(telefone, mensagem) {
                const tel = this.formatarTelefone(telefone);
                const msg = encodeURIComponent(mensagem);
                // Formato: whatsapp://send?phone=55{tel}&text={msg}
                return `whatsapp://send?phone=55${tel}&text=${msg}`;
            }

            // Compatibilidade: método único para gerar link (usado pela UI)
            // Atualmente delega para o link web (wa.me). Se desejar priorizar
            // abertura no aplicativo nativo, altere para `this.gerarLinkApp`.
            gerarLink(telefone, mensagem) {
                return this.gerarLinkWeb(telefone, mensagem);
            }

            // Tenta abrir o WhatsApp instalado via URI scheme. Não abre web.whatsapp.com.
            openInApp(telefone, mensagem) {
                const tel = this.formatarTelefone(telefone);
                if (!tel) {
                    showToast('Telefone do cliente não disponível para envio via WhatsApp.', 'warning');
                    return;
                }

                const appLink = this.gerarLinkApp(telefone, mensagem);

                // Criar um link temporário e forçar clique
                const a = document.createElement('a');
                a.href = appLink;
                a.style.display = 'none';
                document.body.appendChild(a);

                // Tentar abrir app — se não houver handler, o navegador normalmente ignora a ação.
                a.click();
                document.body.removeChild(a);

                // Informar ao usuário caso o app não seja aberto
                setTimeout(() => {
                    showToast('Se o WhatsApp não abriu, verifique se o WhatsApp Desktop está instalado no computador.', 'info');
                }, 1200);
            }

            // Gera texto simples do recibo (para usar no corpo do WhatsApp ou imprimir)
            gerarReciboTexto(cliente, duplicata) {
                const nome = cliente && cliente.nome ? cliente.nome : (duplicata.cliente || 'Cliente');
                const telefone = cliente && cliente.telefone ? cliente.telefone : '';
                const dataPagamento = duplicata.dataPagamento || new Date().toISOString().split('T')[0];
                const valor = duplicata.valor != null ? Number(duplicata.valor).toFixed(2) : '0.00';

                return `RECIBO DE PAGAMENTO\n\nOficina Mecânica Nego Car\nCliente: ${nome}\nTelefone: ${telefone}\nDescrição: ${duplicata.descricao}\nParcela: ${duplicata.parcela || ''}\nData Pagamento: ${this.formatarDataBR(dataPagamento)}\nValor: R$ ${valor}\n\nObservações: ${duplicata.observacoes || ''}\n\nObrigado pela preferência!`;
            }

            // Abre uma janela imprimível com o recibo e um botão para enviar via WhatsApp (app)
            abrirReciboImprimivel(cliente, duplicata) {
                const reciboHtml = `\
                    <html>\n\
                    <head>\n\
                        <meta charset="utf-8" />\n\
                        <title>Recibo de Pagamento</title>\n\
                        <style>\n\
                            body { font-family: Arial, sans-serif; margin: 20px; color: #222 }\n\
                            .recibo { max-width: 720px; margin: auto; border: 1px solid #ddd; padding: 20px; }\n\
                            h2 { margin-top: 0; }\n\
                            .linha { display: flex; justify-content: space-between; margin: 6px 0; }\n\
                            .btns { margin-top: 18px; display:flex; gap:10px }\n\
                            .btn { padding: 8px 12px; border-radius: 4px; border: none; cursor: pointer }\n\
                            .btn-print { background:#2ecc71; color:white }\n\
                            .btn-whatsapp { background:#25D366; color:white }\n\
                        </style>\n\
                    </head>\n\
                    <body>\n\
                        <div class="recibo">\n\
                            <h2>Recibo de Pagamento</h2>\n\
                            <div class="linha"><strong>Oficina:</strong><span>Oficina Mecânica Nego Car</span></div>\n\
                            <div class="linha"><strong>Cliente:</strong><span>${cliente && cliente.nome ? cliente.nome : (duplicata.cliente || '')}</span></div>\n\
                            <div class="linha"><strong>Telefone:</strong><span>${cliente && cliente.telefone ? cliente.telefone : ''}</span></div>\n\
                            <div class="linha"><strong>Descrição:</strong><span>${duplicata.descricao || ''}</span></div>\n\
                            <div class="linha"><strong>Parcela:</strong><span>${duplicata.parcela || ''}</span></div>\n\
                            <div class="linha"><strong>Data Pagamento:</strong><span>${this.formatarDataBR(duplicata.dataPagamento || new Date().toISOString().split('T')[0])}</span></div>\n\
                            <div class="linha"><strong>Valor:</strong><span>R$ ${Number(duplicata.valor || 0).toFixed(2)}</span></div>\n\
                            <div style="margin-top:10px"><strong>Observações:</strong><div>${duplicata.observacoes || ''}</div></div>\n\
                            <div class="btns">\n\
                                <button class="btn btn-print" onclick="window.print()">Imprimir / Salvar PDF</button>\n\
                                <a id="whatsapp-app-link" class="btn btn-whatsapp" href="#">Enviar via WhatsApp (App)</a>\n\
                            </div>\n\
                        </div>\n\
                    </body>\n\
                    </html>\n\
                `;

                const w = window.open('', '_blank', 'toolbar=0,location=0,menubar=0,width=800,height=700');
                if (!w) {
                    showToast('Não foi possível abrir a janela de recibo. Verifique o bloqueador de popups.', 'error');
                    return;
                }
                w.document.open();
                w.document.write(reciboHtml);
                w.document.close();

                // Depois que o conteúdo carregar, configurar o link do botão para abrir o app nativo
                w.addEventListener('load', () => {
                    try {
                        const msg = this.gerarReciboTexto(cliente, duplicata);
                        const tel = cliente && cliente.telefone ? cliente.telefone : '';
                        const appLink = this.gerarLinkApp(tel, msg);
                        const btn = w.document.getElementById('whatsapp-app-link');
                        if (btn) {
                            btn.setAttribute('href', appLink);
                            btn.addEventListener('click', (e) => {
                                // Ao clicar, tentamos abrir o app nativo
                                // O próprio link usa whatsapp://, que deve acionar o handler
                                setTimeout(() => {
                                    // Caso o app não abra, informar no parent
                                    showToast('Se o WhatsApp não abriu, verifique se o WhatsApp Desktop está instalado.', 'info');
                                }, 1200);
                            });
                        }
                    } catch (err) {
                        console.warn('Erro ao preparar link de WhatsApp no recibo:', err);
                    }
                });
            }
        }

        // UI Manager
        class UIManager {
            constructor() {
                this.db = new Database();
                this.syncManager = new SyncManager();
                this.whatsappManager = new WhatsAppManager();
                this.duplicataAtual = null;
                this.clienteAtual = null;
                this.orcamentoAtual = null;
                this.clienteSelecionado = null;
            }

            async init() {
                await this.db.init();
                await this.migrarClientesFinanceiro();
                this.carregarReceber();
            }

            // Tentativa de migrar clientes do localStorage (index.html) para o storage usado por este módulo
            async migrarClientesFinanceiro() {
                try {
                    // Se já houver clientes no storage do módulo, não migrar
                    const existentes = this.db.getAllSync('clientes');
                    if (existentes && existentes.length > 0) return;

                    const fromLS = localStorage.getItem('clientes');
                    if (!fromLS) return;

                    const clientes = JSON.parse(fromLS || '[]');
                    for (const c of clientes) {
                        const cliente = Object.assign({}, c, { id: String(c.id || Date.now()) });
                        try { await this.db.add('clientes', cliente); } catch (e) { console.warn('migração cliente erro', e); }
                    }

                    console.log('Migração de clientes para módulo financeiro (localStorage) concluída');
                } catch (err) {
                    console.warn('Erro em migrarClientesFinanceiro:', err);
                }
            }

            // Dados vêm do index.html via localStorage, não precisa criar exemplos

            async carregarDadosDashboard() {
                const receberHoje = await this.db.getTotalReceberHoje();
                const pagarHoje = await this.db.getTotalPagarHoje();
                
                document.getElementById('receber-hoje').textContent = 
                    this.formatarMoeda(receberHoje);
                document.getElementById('pagar-hoje').textContent = 
                    this.formatarMoeda(pagarHoje);
                
                // Saldo do mês: total de receber (aberto + pago) menos total de pagar (aberto + pago)
                const receber = await this.db.getAll('receber');
                const pagar = await this.db.getAll('pagar');
                
                const totalReceber = receber.reduce((sum, r) => sum + (r.valor || 0), 0);
                const totalPagar = pagar.reduce((sum, p) => sum + (p.valor || 0), 0);
                const saldoMes = totalReceber - totalPagar;
                
                document.getElementById('saldo-mes').textContent = 
                    this.formatarMoeda(saldoMes);
                
                // Calcular inadimplência: (aberto atrasado / aberto total) * 100
                const atraso = receber.filter(r => (r.status || '').toLowerCase() === 'atrasado').length;
                const aberto = receber.filter(r => (r.status || '').toLowerCase() === 'aberto' || (r.status || '').toLowerCase() === 'atrasado').length;
                const percentualInadimplencia = aberto > 0 ? Math.round((atraso / aberto) * 100) : 0;
                
                document.getElementById('inadimplencia').textContent = 
                    `${percentualInadimplencia}%`;
                
                // Atualizar gráfico de inadimplência
                this.atualizarGraficoInadimplencia(atraso, aberto - atraso);
                
                // Carregar vencimentos hoje
                const vencimentos = await this.db.getVencimentosHoje();
                this.atualizarVencimentosHoje(vencimentos);
                
                // Carregar últimos recebimentos
                const ultimosRecebimentos = await this.db.getUltimosRecebimentos();
                this.atualizarUltimosRecebimentos(ultimosRecebimentos);
                
                // Carregar últimos pagamentos
                const ultimosPagamentos = await this.db.getUltimosPagamentos();
                this.atualizarUltimosPagamentos(ultimosPagamentos);
            }

            atualizarVencimentosHoje(vencimentos) {
                const container = document.getElementById('vencimentos-hoje');
                let html = '';
                
                vencimentos.receber.forEach(item => {
                    html += `
                        <div class="vencimento-item">
                            <div class="vencimento-info">
                                <h4><span class="badge badge-warning">A Receber</span> ${item.cliente}</h4>
                                <span>${item.descricao}</span>
                            </div>
                            <div class="vencimento-valor">
                                R$ ${item.valor.toFixed(2)}
                            </div>
                        </div>
                    `;
                });
                
                vencimentos.pagar.forEach(item => {
                    html += `
                        <div class="vencimento-item">
                            <div class="vencimento-info">
                                <h4><span class="badge badge-danger">A Pagar</span> ${item.fornecedor}</h4>
                                <span>${item.descricao}</span>
                            </div>
                            <div class="vencimento-valor">
                                R$ ${item.valor.toFixed(2)}
                            </div>
                        </div>
                    `;
                });
                
                if (!html) {
                    html = '<div class="text-center">Nenhum vencimento para hoje</div>';
                }
                
                container.innerHTML = html;
            }

            atualizarGraficoInadimplencia(atrasados, emDia) {
                const ctx = document.getElementById('inadimplencia-chart');
                if (!ctx) return;
                
                // Se o gráfico já existe, atualizar
                if (this._inadimplenciaChart) {
                    this._inadimplenciaChart.data.datasets[0].data = [atrasados, emDia];
                    this._inadimplenciaChart.update();
                    return;
                }

                // Criar novo gráfico de pizza
                this._inadimplenciaChart = new Chart(ctx.getContext('2d'), {
                    type: 'doughnut',
                    data: {
                        labels: ['Atrasado', 'Em Dia'],
                        datasets: [{
                            data: [atrasados, emDia],
                            backgroundColor: [
                                'rgba(231, 76, 60, 0.8)',
                                'rgba(39, 174, 96, 0.8)'
                            ],
                            borderColor: [
                                'rgba(231, 76, 60, 1)',
                                'rgba(39, 174, 96, 1)'
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: false,
                        plugins: {
                            legend: { position: 'bottom' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percent = ((value / total) * 100).toFixed(0);
                                        return `${label}: ${value} (${percent}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            atualizarUltimosRecebimentos(recebimentos) {
                const container = document.getElementById('ultimos-recebimentos');
                let html = '';
                
                recebimentos.forEach(item => {
                    html += `
                        <div class="recent-item">
                            <div class="recent-info">
                                <h4>${item.cliente}</h4>
                                <span>${this.formatarData(item.dataPagamento)}</span>
                            </div>
                            <div class="recent-valor">
                                R$ ${item.valor.toFixed(2)}
                            </div>
                        </div>
                    `;
                });
                
                if (!html) {
                    html = '<div class="text-center">Nenhum recebimento recente</div>';
                }
                
                container.innerHTML = html;
            }

            atualizarUltimosPagamentos(pagamentos) {
                const container = document.getElementById('ultimos-pagamentos');
                let html = '';
                
                pagamentos.forEach(item => {
                    html += `
                        <div class="recent-item">
                            <div class="recent-info">
                                <h4>${item.fornecedor}</h4>
                                <span>${this.formatarData(item.dataPagamento)}</span>
                            </div>
                            <div class="recent-valor">
                                R$ ${item.valor.toFixed(2)}
                            </div>
                        </div>
                    `;
                });
                
                if (!html) {
                    html = '<div class="text-center">Nenhum pagamento recente</div>';
                }
                
                container.innerHTML = html;
            }

            async carregarReceber() {
                const receber = await this.db.getAll('receber');
                const tabela = document.getElementById('tabela-receber');
                let html = '';
                
                const clientes = this.db.getAllSync('clientes');

                // helpers locais
                const formatarData = (d) => this.formatarData(d);
                const renderizarStatus = (it) => this.criarBadgeStatus(it);
                const renderizarAcoes = (it) => `
                        <button class="btn btn-success btn-sm" onclick="ui.marcarComoPago('${it.id}')">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="btn btn-whatsapp btn-sm" onclick="ui.enviarWhatsAppDuplicata('${it.id}')">
                            <i class="fab fa-whatsapp"></i>
                        </button>
                    `;

                // Agrupar por grupoParcelamentoId quando disponível
                const groups = {};
                receber.forEach(item => {
                    const key = item.grupoParcelamentoId || item.id;
                    if (!groups[key]) groups[key] = { id: key, items: [] };
                    groups[key].items.push(item);
                });

                const groupKeys = Object.keys(groups);
                groupKeys.forEach(key => {
                    const group = groups[key];
                    // calcular resumo do grupo
                    const totalGroup = group.items.reduce((s, it) => s + Number(it.valor || 0), 0);
                    // resolver nome do cliente de forma robusta (evitar 'undefined' literal)
                    const resolveFromItem = (it) => {
                        if (!it) return null;
                        const c = it.cliente;
                        if (c && typeof c === 'object') return c.nome || c.nomeFantasia || null;
                        if (c && typeof c === 'string') {
                            const trimmed = c.trim();
                            if (!trimmed || trimmed.toLowerCase() === 'undefined' || trimmed.toLowerCase() === 'null') return null;
                            return trimmed;
                        }
                        if (it.clienteNome) return it.clienteNome;
                        return null;
                    };

                    const clienteNome = resolveFromItem(group.items[0]) || clientsFindNombre(group.items[0]) || '—';

                    function clientsFindNombre(it) {
                        const cid = it.clienteId || it.cliente_id || it.cliente;
                        if (!cid) return null;
                        const found = clientes.find(c => String(c.id) === String(cid));
                        return found ? (found.nome || found.nomeFantasia || found.razao || String(found.id)) : null;
                    }
                    const descricaoGrupo = group.items[0].descricao || '';

                    // Cabeçalho do grupo (apenas quando há mais de 1 parcela ou quando veio com grupoParcelamentoId)
                    if (group.items.length > 1 || group.items[0].grupoParcelamentoId) {
                        html += `
                            <tr class="group-header">
                                <td colspan="7">
                                    <div style="display:flex;justify-content:space-between;align-items:center">
                                        <div>
                                            <strong>${clienteNome}</strong> — ${descricaoGrupo} — ${group.items.length} parcela(s) — ${this.formatarMoeda(totalGroup)}
                                        </div>
                                        <div>
                                            <button class="btn btn-sm" onclick="ui.toggleGrupo('${key}')">Mostrar / Ocultar</button>
                                        </div>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }

                    // Linhas das parcelas (filhas do grupo)
                    group.items.forEach(item => {
                        const nomeCliente = item.cliente || clientes.find(c => String(c.id) === String(item.clienteId))?.nome || '—';
                        const tr = document.createElement('tr');
                        tr.setAttribute('data-grupo', key);
                        tr.className = 'group-item';
                        tr.innerHTML = `
                            <td>${nomeCliente}</td>
                            <td><a href="#" onclick="ui.visualizarDuplicata('${item.id}'); return false;">${item.descricao || ''}</a></td>
                            <td>${item.parcela || ''}</td>
                            <td>${this.formatarMoeda(item.valor || 0)}</td>
                            <td>${formatarData(item.vencimento)}</td>
                            <td>${renderizarStatus(item.status)}</td>
                            <td>${renderizarAcoes(item)}</td>
                        `;

                        html += tr.outerHTML;
                    });
                });
                
                tabela.innerHTML = html || '<tr><td colspan="7" class="text-center">Nenhuma conta a receber</td></tr>';
            }

            async carregarPagar() {
                const pagar = await this.db.getAll('pagar');
                const tabela = document.getElementById('tabela-pagar');
                let html = '';
                
                pagar.forEach(item => {
                    html += `
                        <tr>
                            <td>${item.fornecedor}</td>
                            <td>${item.descricao}</td>
                            <td>${item.parcela || '1/1'}</td>
                            <td>R$ ${item.valor.toFixed(2)}</td>
                            <td>${this.formatarData(item.vencimento)}</td>
                            <td>${this.criarBadgeStatus(item)}</td>
                            <td>
                                <button class="btn btn-success btn-sm" onclick="ui.marcarComoPagoPagar('${item.id}')">
                                    <i class="fas fa-check"></i>
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                tabela.innerHTML = html || '<tr><td colspan="7" class="text-center">Nenhuma conta a pagar</td></tr>';
            }

            criarBadgeStatus(statusOrItem) {
                // Aceita tanto uma string de status quanto o próprio objeto 'item'
                let status = '';
                let item = null;
                if (statusOrItem && typeof statusOrItem === 'object') {
                    item = statusOrItem;
                    status = (item.status || item.situacao || item.estado || '') + '';
                } else {
                    status = (statusOrItem || '') + '';
                }

                status = status.toLowerCase();

                // Detectar se o item é parcelado (quando for passado o objeto)
                const isParcelado = (() => {
                    if (!item) return false;
                    if (item.parcelado === true || item.parcelado === 'true' || item.parcelado === 1 || item.parcelado === '1') return true;
                    const tipo = (item.tipo || item.forma || '').toString().toLowerCase();
                    if (tipo === 'parcelado') return true;
                    const parcela = (item.parcela || item.parcela_de || item.numero_parcela || '');
                    const pstr = parcela.toString();
                    if (pstr && pstr.indexOf('/') !== -1) {
                        const parts = pstr.split('/').map(s => s.trim());
                        if (parts.length === 2 && parts[0] !== parts[1]) return true;
                    }
                    if ((Number(item.numParcelas) || Number(item.total_parcelas) || Number(item.totalParcelas) || 0) > 1) return true;
                    return false;
                })();

                // Se for parcelado e status aberto/pendente, mostrar 'Aberto/Parcelado'
                if (isParcelado && (status === 'aberto' || status === 'pendente' || status === '')) {
                    return '<span class="badge badge-warning">Aberto/Parcelado</span>';
                }

                switch(status) {
                    case 'aberto': return '<span class="badge badge-warning">Aberto</span>';
                    case 'pago': return '<span class="badge badge-success">Pago</span>';
                    case 'atrasado': return '<span class="badge badge-danger">Atrasado</span>';
                    default: return '<span class="badge">' + (status || (item && (item.parcelado ? 'Parcelado' : '')) ) + '</span>';
                }
            }

            formatarMoeda(valor) {
                return new Intl.NumberFormat('pt-BR', {
                    style: 'currency',
                    currency: 'BRL'
                }).format(valor);
            }

            formatarData(dataISO) {
                if (!dataISO) return '-';
                return new Date(dataISO).toLocaleDateString('pt-BR');
            }

            async verificarVencimentos() {
                const hoje = new Date().toISOString().split('T')[0];
                const receber = await this.db.getAll('receber', 'vencimento', hoje);
                
                const vencimentosHoje = receber.filter(r => r.status === 'aberto');
                
                if (vencimentosHoje.length > 0) {
                    const primeiro = vencimentosHoje[0];
                    // Buscar cliente do localStorage compartilhado
                    const clientes = this.db.getAllSync('clientes');
                    const cliente = clientes.find(c => c.id == primeiro.clienteId) || { nome: 'Cliente' };
                    
                    this.duplicataAtual = primeiro;
                    this.clienteAtual = cliente;
                    
                    // Mostrar notificação de vencimento
                    showToast(`${cliente.nome} tem uma duplicata vencendo hoje!`, 'warning');
                }
            }

            // Atualiza status persistente de vencimentos: marca como 'atrasado' quando vencimento < hoje e não está pago
            async atualizarStatusVencimentosPersistente() {
                try {
                    const hoje = new Date().toISOString().split('T')[0];
                    const receber = await this.db.getAll('receber');

                    for (const item of receber) {
                        const statusAtual = (item.status || '').toLowerCase();

                        if (statusAtual === 'pago') continue; // não altera pagamentos

                        if (item.vencimento) {
                            const venc = item.vencimento;
                            if (venc < hoje && statusAtual !== 'atrasado') {
                                item.status = 'atrasado';
                                await this.db.put('receber', item);
                            } else if (venc >= hoje && statusAtual === 'atrasado') {
                                // caso a data seja atualizada para futuro, reverter para 'aberto'
                                item.status = 'aberto';
                                await this.db.put('receber', item);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Erro ao atualizar status de vencimentos:', error);
                }
            }

            async marcarComoPago(id) {
                try {
                    const duplicata = await this.db.get('receber', id);
                    if (!duplicata) return;
                    
                    duplicata.status = 'pago';
                    duplicata.dataPagamento = new Date().toISOString().split('T')[0];
                    
                    await this.db.put('receber', duplicata);
                    
                    // Abrir recibo/imprimir e oferecer envio via WhatsApp (app)
                    try {
                        const cliente = await this.db.get('clientes', duplicata.clienteId);
                        this.whatsappManager.abrirReciboImprimivel(cliente, duplicata);
                    } catch (err) {
                        console.warn('Erro ao abrir recibo após marcar como pago:', err);
                    }

                    showToast('Duplicata marcada como paga!', 'success');
                    this.carregarReceber();
                    this.carregarDadosDashboard();
                    
                } catch (error) {
                    console.error('Erro ao marcar como pago:', error);
                    showToast('Erro ao marcar como pago', 'error');
                }
            }

            async marcarComoPagoPagar(id) {
                try {
                    const duplicata = await this.db.get('pagar', id);
                    if (!duplicata) return;
                    
                    duplicata.status = 'pago';
                    duplicata.dataPagamento = new Date().toISOString().split('T')[0];
                    
                    await this.db.put('pagar', duplicata);
                    
                    showToast('Conta marcada como paga!', 'success');
                    this.carregarPagar();
                    this.carregarDadosDashboard();
                    
                } catch (error) {
                    console.error('Erro ao marcar como pago:', error);
                    showToast('Erro ao marcar como pago', 'error');
                }
            }

            async enviarWhatsAppDuplicata(id) {
                const duplicata = await this.db.get('receber', id);
                if (!duplicata) return;
                
                // Buscar cliente do localStorage compartilhado
                const clientes = this.db.getAllSync('clientes');
                const cliente = clientes.find(c => String(c.id) === String(duplicata.clienteId) || String(c.id) === String(duplicata.cliente_id) || String(c.id) === String(duplicata.cliente)) || null;

                // Tentar extrair telefone robustamente
                const telefoneEncontrado = this.whatsappManager ? this.whatsappManager.obterTelefoneCliente(cliente) : (cliente && (cliente.telefone || cliente.whatsapp) ? String(cliente.telefone || cliente.whatsapp).replace(/\D/g,'') : '');
                if (!cliente || !telefoneEncontrado) {
                    showToast('Cliente sem telefone cadastrado', 'warning');
                    return;
                }
                
                this.duplicataAtual = duplicata;
                this.clienteAtual = cliente;
                
                const mensagem = this.whatsappManager.gerarMensagem(cliente, duplicata);
                document.getElementById('mensagem-whatsapp').value = mensagem;
                // salvar telefone limpo no clienteAtual para uso posterior
                cliente._telefoneParaWhats = telefoneEncontrado;
                
                showModal('modal-whatsapp');
            }

            async visualizarDuplicata(id) {
                try {
                    const duplicata = await this.db.get('receber', id);
                    if (!duplicata) return;

                    const clientes = this.db.getAllSync('clientes');
                    const cliente = clientes.find(c => String(c.id) === String(duplicata.clienteId) || String(c.id) === String(duplicata.cliente_id) || String(c.id) === String(duplicata.cliente)) || null;

                    this.duplicataAtual = duplicata;
                    this.clienteAtual = cliente;

                    // preencher modal de visualização
                    document.getElementById('vis-dup-cliente').innerText = cliente && cliente.nome ? cliente.nome : (duplicata.cliente || '—');
                    document.getElementById('vis-dup-telefone').innerText = cliente && (cliente.telefone || cliente.whatsapp) ? (cliente.telefone || cliente.whatsapp) : '';
                    document.getElementById('vis-dup-descricao').innerText = duplicata.descricao || '';
                    document.getElementById('vis-dup-parcela').innerText = duplicata.parcela || '';
                    document.getElementById('vis-dup-vencimento').innerText = this.formatarData(duplicata.vencimento);
                    document.getElementById('vis-dup-valor').innerText = this.formatarMoeda(Number(duplicata.valor || 0));
                    document.getElementById('vis-dup-status').innerHTML = this.criarBadgeStatus(duplicata);

                    // preencher mensagem whatsapp no modal de envio (pré-visualização)
                    try {
                        const mensagem = whatsappManager.gerarMensagem(cliente, duplicata);
                        document.getElementById('mensagem-whatsapp').value = mensagem;
                    } catch (e) {}

                    // armazenar telefone limpo
                    try {
                        if (cliente) cliente._telefoneParaWhats = whatsappManager.obterTelefoneCliente(cliente);
                    } catch (e) {}

                    showModal('modal-visualizar-duplicata');
                } catch (err) {
                    console.error('Erro ao abrir visualização da duplicata:', err);
                }
            }

            async buscarCliente(nome) {
                if (!nome || nome.trim() === '') {
                    const datalist = document.getElementById('clientes-list');
                    datalist.innerHTML = '';
                    const sugestoes = document.getElementById('sugestoes-cliente');
                    if (sugestoes) sugestoes.style.display = 'none';
                    this.clienteSelecionado = null;
                    document.getElementById('cliente-info').classList.add('hidden');
                    document.getElementById('orcamento').innerHTML = '<option value="">Selecione um orçamento...</option>';
                    document.getElementById('orcamento-info').classList.add('hidden');
                    return;
                }
                
                const clientes = await this.db.buscarClientesPorNome(nome);
                const datalist = document.getElementById('clientes-list');
                const sugestoes = document.getElementById('sugestoes-cliente');
                
                // Limpar datalist
                datalist.innerHTML = '';
                
                // Limpar e preencher sugestões
                if (sugestoes) {
                    sugestoes.innerHTML = '';
                    if (clientes.length > 0) {
                        sugestoes.style.display = 'block';
                        clientes.forEach(cliente => {
                            const div = document.createElement('div');
                            div.style.padding = '10px';
                            div.style.cursor = 'pointer';
                            div.style.borderBottom = '1px solid #eee';
                            div.textContent = cliente.nome;
                            div.onmouseover = () => div.style.background = '#f0f0f0';
                            div.onmouseout = () => div.style.background = 'white';
                            div.onclick = () => {
                                document.getElementById('buscar-cliente').value = cliente.nome;
                                this.selecionarCliente(cliente);
                                sugestoes.style.display = 'none';
                            };
                            sugestoes.appendChild(div);
                        });
                    } else {
                        sugestoes.style.display = 'none';
                    }
                }
                
                clientes.forEach(cliente => {
                    const option = document.createElement('option');
                    option.value = cliente.nome;
                    option.dataset.id = cliente.id;
                    datalist.appendChild(option);
                });
                
                // Se encontrou exatamente um cliente com nome exato, preencher informações
                const clienteExato = clientes.find(c => c.nome.toLowerCase().trim() === nome.toLowerCase().trim());
                if (clienteExato) {
                    await this.selecionarCliente(clienteExato);
                    if (sugestoes) sugestoes.style.display = 'none';
                } else if (clientes.length === 0) {
                    this.clienteSelecionado = null;
                    document.getElementById('cliente-info').classList.add('hidden');
                    document.getElementById('orcamento').innerHTML = '<option value="">Selecione um orçamento...</option>';
                    document.getElementById('orcamento-info').classList.add('hidden');
                }
            }
            
            async selecionarClientePorNome(nome) {
                if (!nome || nome.trim() === '') return;
                
                const clientes = await this.db.buscarClientesPorNome(nome);
                const clienteExato = clientes.find(c => c.nome.toLowerCase().trim() === nome.toLowerCase().trim());
                
                if (clienteExato) {
                    await this.selecionarCliente(clienteExato);
                    const sugestoes = document.getElementById('sugestoes-cliente');
                    if (sugestoes) sugestoes.style.display = 'none';
                }
            }

            async selecionarCliente(cliente) {
                this.clienteSelecionado = cliente;
                
                console.log('=== CLIENTE SELECIONADO ===');
                console.log('Cliente completo:', cliente);
                console.log('Cliente ID:', cliente.id, 'Tipo:', typeof cliente.id);
                
                // Buscar veículos do cliente (do localStorage compartilhado)
                const veiculos = JSON.parse(localStorage.getItem('veiculos') || '[]');
                const clienteIdNormalizado = cliente.id != null ? String(cliente.id) : null;
                const veiculosCliente = veiculos.filter(v => {
                    const vClienteId = v.clienteId != null ? String(v.clienteId) : null;
                    return vClienteId === clienteIdNormalizado;
                });
                const veiculoTexto = veiculosCliente.length > 0 
                    ? veiculosCliente.map(v => `${v.marca || ''} ${v.modelo || ''} ${v.ano || ''}`.trim()).join(', ')
                    : 'Não informado';
                
                // Mostrar informações do cliente
                document.getElementById('info-cliente-nome').textContent = cliente.nome;
                document.getElementById('info-cliente-telefone').textContent = cliente.whatsapp || cliente.telefone || 'Não informado';
                document.getElementById('info-cliente-veiculo').textContent = veiculoTexto;
                document.getElementById('cliente-info').classList.remove('hidden');
                
                // Preencher campo de busca
                document.getElementById('buscar-cliente').value = cliente.nome;
                
                // Carregar orçamentos do cliente - usar o ID do cliente
                const clienteId = cliente.id;
                console.log('Iniciando carregamento de orçamentos para cliente ID:', clienteId);
                await this.carregarOrcamentosCliente(clienteId);
            }

            async carregarOrcamentosCliente(clienteId) {
                console.log('=== CARREGANDO ORÇAMENTOS ===');
                console.log('Cliente ID recebido:', clienteId, 'Tipo:', typeof clienteId);
                
                const orcamentos = await this.db.getOrcamentosAprovadosPorCliente(clienteId);
                const select = document.getElementById('orcamento');

                console.log('Orçamentos retornados:', orcamentos);
                console.log('Quantidade de orçamentos:', orcamentos ? orcamentos.length : 0);

                select.innerHTML = '<option value="">Selecione um orçamento...</option>';

                // Filtrar orçamentos que já possuem lançamento (receber)
                const recebimentos = await this.db.getAll('receber');
                const orcamentosDisponiveis = (orcamentos || []).filter(o => {
                    // Excluir se existir qualquer recebimento com orcamentoId igual
                    const existe = recebimentos.some(r => String(r.orcamentoId) === String(o.id));
                    if (existe) {
                        console.log('Orçamento removido da lista (já lançado):', o.id, o.numero);
                    }
                    return !existe;
                });

                if (orcamentosDisponiveis && orcamentosDisponiveis.length > 0) {
                    console.log('✅ Preenchendo dropdown com', orcamentosDisponiveis.length, 'orçamentos disponíveis');
                    orcamentosDisponiveis.forEach((orcamento, index) => {
                        const option = document.createElement('option');
                        option.value = orcamento.id;
                        // Usar total se valorTotal não existir
                        const valor = orcamento.valorTotal || orcamento.total || 0;
                        const numero = orcamento.numero || `#${orcamento.id}`;
                        option.textContent = `OS ${numero} - ${this.formatarMoeda(valor)}`;
                        select.appendChild(option);
                        console.log(`  ${index + 1}. Orçamento ${numero} - R$ ${valor}`);
                    });
                } else {
                    console.warn('⚠️ Nenhum orçamento encontrado, verificando detalhes...');
                    
                    // Verificar se há orçamentos aprovados ou finalizados
                    const todosOrcamentos = this.db.getAllSync('orcamentos');
                    const clienteIdNormalizado = clienteId != null ? String(clienteId) : null;
                    
                    console.log('Total de orçamentos no sistema:', todosOrcamentos.length);
                    
                    const orcamentosAprovadosEFinalizados = todosOrcamentos.filter(orcamento => {
                        const orcClienteId = orcamento.clienteId != null ? String(orcamento.clienteId) : null;
                        const orcClienteIdAlt = orcamento.cliente_id != null ? String(orcamento.cliente_id) : null;
                        const clienteOk = orcClienteId === clienteIdNormalizado || orcClienteIdAlt === clienteIdNormalizado;
                        // Aceitar orçamentos aprovados OU finalizados
                        const statusOk = orcamento.status === 'aprovado' || orcamento.status === 'finalizado';
                        
                        if (clienteOk) {
                            console.log('Orçamento do cliente encontrado:', {
                                id: orcamento.id,
                                numero: orcamento.numero,
                                status: orcamento.status,
                                statusOk: statusOk
                            });
                        }
                        
                        return clienteOk && statusOk;
                    });
                    
                    console.log('Orçamentos aprovados e finalizados do cliente:', orcamentosAprovadosEFinalizados.length);
                    
                    if (orcamentosAprovadosEFinalizados.length === 0) {
                        select.innerHTML = '<option value="">Nenhum orçamento aprovado ou finalizado encontrado para este cliente</option>';
                    } else {
                        // Se chegamos aqui é porque havia orçamentos aprovados, mas todos foram removidos
                        // por já terem lançamentos. Informar ao usuário.
                        select.innerHTML = '<option value="">Todos os orçamentos aprovados já possuem lançamento</option>';
                    }
                }
                
                console.log('=== FIM DO CARREGAMENTO ===');
            }

            async carregarDadosOrcamento(orcamentoId) {
                if (!orcamentoId) {
                    document.getElementById('orcamento-info').classList.add('hidden');
                    return;
                }
                
                const orcamento = await this.db.getOrcamentoCompleto(orcamentoId);
                if (!orcamento) return;
                
                this.orcamentoAtual = orcamento;
                
                // Formatar serviços e peças
                let servicosTexto = '';
                if (Array.isArray(orcamento.servicos)) {
                    servicosTexto = orcamento.servicos.map(s => {
                        if (typeof s === 'string') return s;
                        return s.descricao || s.nome || s.servico || JSON.stringify(s);
                    }).join(', ');
                } else if (typeof orcamento.servicos === 'string') {
                    servicosTexto = orcamento.servicos;
                }
                
                let pecasTexto = '';
                if (Array.isArray(orcamento.pecas)) {
                    pecasTexto = orcamento.pecas.map(p => {
                        if (typeof p === 'string') return p;
                        return p.descricao || p.nome || p.peca || JSON.stringify(p);
                    }).join(', ');
                } else if (typeof orcamento.pecas === 'string') {
                    pecasTexto = orcamento.pecas;
                }
                
                // Mostrar informações do orçamento
                document.getElementById('info-orcamento-numero').textContent = orcamento.numero || `#${orcamento.id}`;
                document.getElementById('info-orcamento-data').textContent = this.formatarData(orcamento.data);
                document.getElementById('info-orcamento-servicos').textContent = servicosTexto || 'Nenhum serviço';
                document.getElementById('info-orcamento-pecas').textContent = pecasTexto || 'Nenhuma peça';
                document.getElementById('info-orcamento-total').textContent = this.formatarMoeda(orcamento.valorTotal || 0);
                
                document.getElementById('orcamento-info').classList.remove('hidden');
                
                // Atualizar cálculo de parcelas
                this.calcularParcelas();
            }

            calcularParcelas() {
                if (!this.orcamentoAtual) return;
                
                const tipoPagamento = document.getElementById('tipo-pagamento').value;
                const valorTotal = this.orcamentoAtual.valorTotal;
                
                if (tipoPagamento === 'parcelado') {
                    const numParcelas = parseInt(document.getElementById('numero-parcelas').value);
                    const dataPrimeira = document.getElementById('data-primeira-parcela').value;
                    
                    if (!dataPrimeira) return;
                    
                    const valorParcela = valorTotal / numParcelas;
                    const tbody = document.getElementById('lista-parcelas');
                    tbody.innerHTML = '';
                    
                    for (let i = 1; i <= numParcelas; i++) {
                        const dataVencimento = new Date(dataPrimeira);
                        dataVencimento.setMonth(dataVencimento.getMonth() + (i - 1));
                        
                        const tr = document.createElement('tr');
                        tr.innerHTML = `
                            <td>${i}/${numParcelas}</td>
                            <td>${dataVencimento.toLocaleDateString('pt-BR')}</td>
                            <td>${this.formatarMoeda(valorParcela)}</td>
                        `;
                        tbody.appendChild(tr);
                    }
                    
                    document.getElementById('tabela-parcelas').classList.remove('hidden');
                    
                } else if (tipoPagamento === 'entrada') {
                    const valorEntrada = parseFloat(document.getElementById('valor-entrada').value) || 0;
                    const numParcelas = parseInt(document.getElementById('numero-parcelas-entrada').value) || 1;
                    const dataPrimeira = document.getElementById('data-primeira-parcela-entrada').value;
                    
                    if (!this.orcamentoAtual) return;
                    
                    const valorTotal = this.orcamentoAtual.valorTotal;
                    
                    if (valorEntrada <= 0) {
                        document.getElementById('tabela-entrada-parcelas').classList.add('hidden');
                        return;
                    }
                    
                    if (!dataPrimeira) {
                        // Definir data padrão se não estiver definida
                        const data30dias = new Date();
                        data30dias.setDate(data30dias.getDate() + 30);
                        document.getElementById('data-primeira-parcela-entrada').value = data30dias.toISOString().split('T')[0];
                        return;
                    }
                    
                    const valorRestante = valorTotal - valorEntrada;
                    
                    if (valorRestante < 0) {
                        showToast('O valor da entrada não pode ser maior que o valor total!', 'error');
                        document.getElementById('tabela-entrada-parcelas').classList.add('hidden');
                        return;
                    }
                    
                    const valorParcela = numParcelas > 0 ? valorRestante / numParcelas : 0;
                    const tbody = document.getElementById('lista-entrada-parcelas');
                    tbody.innerHTML = '';
                    
                    // Entrada
                    if (valorEntrada > 0) {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `
                            <td><strong>Entrada</strong></td>
                            <td>${new Date().toLocaleDateString('pt-BR')}</td>
                            <td><strong>${this.formatarMoeda(valorEntrada)}</strong></td>
                        `;
                        tbody.appendChild(tr);
                    }
                    
                    // Parcelas
                    if (numParcelas > 0 && valorRestante > 0) {
                        for (let i = 1; i <= numParcelas; i++) {
                            const dataVencimento = new Date(dataPrimeira);
                            dataVencimento.setMonth(dataVencimento.getMonth() + (i - 1));
                            
                            const tr = document.createElement('tr');
                            tr.innerHTML = `
                                <td>Parcela ${i}/${numParcelas}</td>
                                <td>${dataVencimento.toLocaleDateString('pt-BR')}</td>
                                <td>${this.formatarMoeda(valorParcela)}</td>
                            `;
                            tbody.appendChild(tr);
                        }
                    }
                    
                    // Linha de total
                    const trTotal = document.createElement('tr');
                    trTotal.style.borderTop = '2px solid #ddd';
                    trTotal.style.fontWeight = 'bold';
                    trTotal.innerHTML = `
                        <td><strong>Total</strong></td>
                        <td></td>
                        <td><strong>${this.formatarMoeda(valorTotal)}</strong></td>
                    `;
                    tbody.appendChild(trTotal);
                    
                    document.getElementById('tabela-entrada-parcelas').classList.remove('hidden');
                }
            }

            calcularParcelasEntrada() {
                this.calcularParcelas();
            }

            gerarParcelasParaSalvar() {
                if (!this.orcamentoAtual || !this.clienteSelecionado) return [];
                
                const tipoPagamento = document.getElementById('tipo-pagamento').value;
                const observacoes = document.getElementById('observacoes').value;
                const valorTotal = this.orcamentoAtual.valorTotal;
                
                const parcelas = [];
                
                if (tipoPagamento === 'parcelado') {
                    const numParcelas = parseInt(document.getElementById('numero-parcelas').value);
                    const dataPrimeira = document.getElementById('data-primeira-parcela').value;
                    const valorParcela = valorTotal / numParcelas;
                    
                    for (let i = 1; i <= numParcelas; i++) {
                        const dataVencimento = new Date(dataPrimeira);
                        dataVencimento.setMonth(dataVencimento.getMonth() + (i - 1));
                        
                        parcelas.push({
                            clienteId: this.clienteSelecionado.id,
                            cliente: this.clienteSelecionado.nome,
                            orcamentoId: this.orcamentoAtual.id,
                            descricao: `Orçamento ${this.orcamentoAtual.numero} - Parcela ${i}/${numParcelas}`,
                            valor: Number(valorParcela.toFixed(2)),
                            vencimento: dataVencimento.toISOString().split('T')[0],
                            status: 'aberto',
                            data: new Date().toISOString().split('T')[0],
                            parcela: `${i}/${numParcelas}`,
                            tipo: 'parcelado',
                            parcelado: true,
                            observacoes: observacoes || ''
                        });
                    }
                    
                } else if (tipoPagamento === 'entrada') {
                    const valorEntrada = parseFloat(document.getElementById('valor-entrada').value) || 0;
                    const numParcelas = parseInt(document.getElementById('numero-parcelas-entrada').value) || 1;
                    const dataPrimeira = document.getElementById('data-primeira-parcela-entrada').value;
                    const valorRestante = valorTotal - valorEntrada;
                    const valorParcela = numParcelas > 0 ? valorRestante / numParcelas : 0;
                    
                    // Entrada
                    if (valorEntrada > 0) {
                        parcelas.push({
                            clienteId: this.clienteSelecionado.id,
                            cliente: this.clienteSelecionado.nome,
                            orcamentoId: this.orcamentoAtual.id,
                            descricao: `Orçamento ${this.orcamentoAtual.numero} - Entrada`,
                            valor: Number(valorEntrada.toFixed(2)),
                            vencimento: new Date().toISOString().split('T')[0],
                            status: 'pago',
                            data: new Date().toISOString().split('T')[0],
                            dataPagamento: new Date().toISOString().split('T')[0],
                            parcela: 'Entrada',
                            tipo: 'entrada',
                            parcelado: true,
                            observacoes: observacoes || ''
                        });
                    }
                    
                    // Parcelas restantes
                    if (numParcelas > 0 && valorRestante > 0) {
                        for (let i = 1; i <= numParcelas; i++) {
                            const dataVencimento = new Date(dataPrimeira);
                            dataVencimento.setMonth(dataVencimento.getMonth() + (i - 1));
                            
                            parcelas.push({
                                clienteId: this.clienteSelecionado.id,
                                cliente: this.clienteSelecionado.nome,
                                orcamentoId: this.orcamentoAtual.id,
                                descricao: `Orçamento ${this.orcamentoAtual.numero} - Parcela ${i}/${numParcelas}`,
                                valor: Number(valorParcela.toFixed(2)),
                                vencimento: dataVencimento.toISOString().split('T')[0],
                                status: 'aberto',
                                data: new Date().toISOString().split('T')[0],
                                parcela: `${i}/${numParcelas}`,
                                tipo: 'parcelado',
                                parcelado: true,
                                observacoes: observacoes || ''
                            });
                        }
                    }
                    
                } else if (tipoPagamento === 'avista') {
                    // À vista
                    parcelas.push({
                        clienteId: this.clienteSelecionado.id,
                        cliente: this.clienteSelecionado.nome,
                        orcamentoId: this.orcamentoAtual.id,
                        descricao: `Orçamento ${this.orcamentoAtual.numero}`,
                        valor: Number(valorTotal),
                        vencimento: new Date().toISOString().split('T')[0],
                        status: 'pago',
                        data: new Date().toISOString().split('T')[0],
                        dataPagamento: new Date().toISOString().split('T')[0],
                        parcela: '1/1',
                        tipo: 'avista',
                        parcelado: false,
                        observacoes: observacoes || ''
                    });
                }
                
                return parcelas;
            }

            async salvarRecebimento() {
                try {
                    // Bloquear novo lançamento se já existir lançamento para o mesmo orçamento
                    if (this.orcamentoAtual) {
                        const recebimentosExistentes = await this.db.getAll('receber');
                        const existeParaOrcamento = recebimentosExistentes.some(r => {
                            return String(r.orcamentoId) === String(this.orcamentoAtual.id);
                        });

                        if (existeParaOrcamento) {
                            showToast('Já existe lançamento para este orçamento', 'warning');
                            return;
                        }
                    }

                    if (!this.clienteSelecionado || !this.orcamentoAtual) {
                        showToast('Selecione cliente e orçamento', 'warning');
                        return;
                    }

                    const cliente = this.clienteSelecionado;
                    if (!cliente) {
                        showToast('Selecione um cliente válido', 'warning');
                        return;
                    }
                    
                    // GERAR PARCELAS
                    const parcelas = this.gerarParcelasParaSalvar();
                    
                    if (!parcelas || parcelas.length === 0) {
                        showToast('Nenhuma parcela gerada. Verifique os dados!', 'warning');
                        return;
                    }
                    
                    // SALVAR CADA PARCELA NO BANCO
                    const parcelasSalvas = [];

                    // Gerar um ID de grupo para vincular todas as parcelas desse parcelamento
                    const grupoParcelamentoId = await this.db.gerarId();
                    
                    for (const parcela of parcelas) {
                        // Atribuir grupo de parcelamento para poder reagrupá-las depois
                        parcela.grupoParcelamentoId = grupoParcelamentoId;

                        // Gerar ID único para cada parcela
                        parcela.id = await this.db.gerarId();
                        
                        // SALVAR NO BANCO DE DADOS
                        const idRetornado = await this.db.add('receber', parcela);
                        
                        // Log detalhado para debug
                        console.log(`[SALVAR RECEBIMENTO] Parcela ID local: ${parcela.id}, ID retornado: ${idRetornado}, syncStatus: ${idRetornado === parcela.id ? 'LOCAL' : 'SINCRONIZADO'}`);
                        
                        parcelasSalvas.push(parcela);
                        
                        console.log(`Parcela salva: ${parcela.parcela} - R$ ${parcela.valor} - ${parcela.vencimento} (grupo ${grupoParcelamentoId})`);
                    }
                    
                    console.log(`Total de parcelas salvas: ${parcelasSalvas.length}`);
                    
                    // WhatsApp: Enviar mensagem com o plano de pagamento
                    try {
                        const clienteTel = cliente.telefone || cliente.whatsapp;
                        if (clienteTel && parcelasSalvas.length > 0) {
                            let msg = `Olá ${cliente.nome.split(' ')[0]}, segue o plano de pagamento para o orçamento ${this.orcamentoAtual.numero}:\n\n`;
                            
                            parcelasSalvas.forEach(p => {
                                const venc = p.vencimento ? this.whatsappManager.formatarDataBR(p.vencimento) : '-';
                                const status = p.status === 'pago' ? '(PAGO)' : '(A PAGAR)';
                                msg += `• ${p.parcela} - Venc: ${venc} - Valor: R$ ${Number(p.valor).toFixed(2)} ${status}\n`;
                            });
                            
                            const total = parcelasSalvas.reduce((sum, p) => sum + (p.valor || 0), 0);
                            msg += `\nTotal: R$ ${total.toFixed(2)}\n`;
                            msg += '\nQualquer dúvida, estamos à disposição.';
                            
                            this.whatsappManager.openInApp(clienteTel, msg);
                        }
                    } catch (err) {
                        console.warn('Erro ao abrir WhatsApp:', err);
                    }
                    
                    // Se houve entrada paga, mostrar recibo
                    const entradaPaga = parcelasSalvas.find(p => p.status === 'pago');
                    if (entradaPaga) {
                        try {
                            this.whatsappManager.abrirReciboImprimivel(cliente, entradaPaga);
                        } catch (err) {
                            console.warn('Erro ao abrir recibo:', err);
                        }
                    }
                    
                    showToast(`Recebimento salvo com sucesso! ${parcelasSalvas.length} parcela(s) criada(s).`, 'success');
                    hideModal('modal-lancamento-receber');
                    
                    // Atualizar a interface
                    this.carregarReceber();
                    this.carregarDadosDashboard();
                    
                    // Limpar formulário
                    this.limparFormularioRecebimento();
                    
                } catch (error) {
                    console.error('Erro ao salvar recebimento:', error);
                    showToast('Erro ao salvar recebimento: ' + (error && error.message ? error.message : error), 'error');
                }
            }

            async salvarPagamento(formData) {
                try {
                    const fornecedor = document.getElementById('fornecedor').value;
                    const descricao = document.getElementById('descricao-pagar').value;
                    const valor = parseFloat(document.getElementById('valor-pagar').value);
                    const vencimento = document.getElementById('vencimento-pagar').value;
                    const tipo = document.getElementById('tipo-pagar').value;
                    const observacoes = document.getElementById('observacoes-pagar').value;
                    
                    const pagamento = {
                        id: await this.db.gerarId(),
                        fornecedor: fornecedor,
                        descricao: descricao,
                        valor: valor,
                        vencimento: vencimento,
                        status: 'aberto',
                        tipo: tipo,
                        observacoes: observacoes
                    };
                    
                    await this.db.add('pagar', pagamento);
                    
                    showToast('Pagamento salvo com sucesso!', 'success');
                    hideModal('modal-lancamento-pagar');
                    this.carregarPagar();
                    this.carregarDadosDashboard();
                    
                    // Limpar formulário
                    document.getElementById('form-pagar').reset();
                    
                } catch (error) {
                    console.error('Erro ao salvar pagamento:', error);
                    showToast('Erro ao salvar pagamento', 'error');
                }
            }

            limparFormularioRecebimento() {
                document.getElementById('form-receber').reset();
                document.getElementById('cliente-info').classList.add('hidden');
                document.getElementById('orcamento-info').classList.add('hidden');
                document.getElementById('tabela-parcelas').classList.add('hidden');
                document.getElementById('tabela-entrada-parcelas').classList.add('hidden');
                document.getElementById('campos-parcelado').classList.add('hidden');
                document.getElementById('campos-entrada').classList.add('hidden');
                this.clienteSelecionado = null;
                this.orcamentoAtual = null;
            }

            toggleGrupo(grupoId) {
                try {
                    const rows = document.querySelectorAll(`[data-grupo='${grupoId}']`);
                    if (!rows || rows.length === 0) return;
                    rows.forEach(r => r.classList.toggle('hidden'));
                } catch (e) {
                    console.warn('Erro ao alternar grupo:', e);
                }
            }

            async iniciarChart() {
                const ctx = document.getElementById('cashflow-chart').getContext('2d');

                // Buscar dados reais do DB
                const fluxo = await this.db.getFluxoCaixa7Dias();

                const labels = fluxo.map(f => {
                    // Mostrar dia curto e data
                    const d = new Date(f.data);
                    return d.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit' });
                });

                const receberData = fluxo.map(f => Number(f.receber || 0));
                const pagarData = fluxo.map(f => Number(f.pagar || 0));
                const saldoData = fluxo.map(f => Number(f.saldo || 0));

                // Se já existir gráfico, apenas atualizar
                if (this._cashflowChart) {
                    this._cashflowChart.data.labels = labels;
                    this._cashflowChart.data.datasets[0].data = receberData;
                    this._cashflowChart.data.datasets[1].data = pagarData;
                    this._cashflowChart.data.datasets[2].data = saldoData;
                    this._cashflowChart.update();
                    return;
                }

                this._cashflowChart = new Chart(ctx, {
                    data: {
                        labels,
                        datasets: [
                            {
                                type: 'bar',
                                label: 'A Receber',
                                data: receberData,
                                backgroundColor: 'rgba(39, 174, 96, 0.7)',
                                borderColor: 'rgba(39, 174, 96, 1)',
                                borderWidth: 1,
                                yAxisID: 'y'
                            },
                            {
                                type: 'bar',
                                label: 'A Pagar',
                                data: pagarData,
                                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                                borderColor: 'rgba(231, 76, 60, 1)',
                                borderWidth: 1,
                                yAxisID: 'y'
                            },
                            {
                                type: 'line',
                                label: 'Saldo',
                                data: saldoData,
                                borderColor: 'rgba(52, 152, 219, 1)',
                                backgroundColor: 'rgba(52, 152, 219, 0.15)',
                                tension: 0.3,
                                fill: false,
                                pointRadius: 4,
                                yAxisID: 'y2'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: { position: 'top' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.dataset.label || '';
                                        const value = context.formattedValue || '0';
                                        return `${label}: ${new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(Number(value))}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { stacked: false },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                ticks: { callback: v => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(v) }
                            },
                            y2: {
                                type: 'linear',
                                display: false,
                                position: 'right'
                            }
                        }
                    }
                });
            }
        }

        // Funções globais
        const ui = new UIManager();
        const syncManager = new SyncManager();
        const whatsappManager = new WhatsAppManager();

        // Tornar instâncias acessíveis globalmente para a sincronização e debug
        // (trySync verifica window.ui e window.ui.db)
        window.ui = ui;
        window.syncManager = syncManager;
        window.whatsappManager = whatsappManager;

        // Inicializar quando o DOM carregar
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('=== INICIANDO SISTEMA FINANCEIRO ===');
            
            // Verificar dados no localStorage
            try {
                const receberNoStorage = localStorage.getItem('financeiro-receber');
                if (receberNoStorage) {
                    const receber = JSON.parse(receberNoStorage);
                    console.log(`Total de registros "receber" no localStorage: ${receber.length}`);
                    if (receber.length > 0) {
                        console.log('Últimos 5 registros:', receber.slice(-5));
                    }
                }
            } catch (err) {
                console.warn('Erro ao ler financeiro-receber do localStorage:', err);
            }

            // Garantir que o botão de limpeza esteja oculto por padrão (apenas admin poderá mostrar)
            try { const _c = document.getElementById('cleanup-btn-container'); if (_c) _c.style.display = 'none'; } catch (e) {}
            await ui.init();
            
            // Configurar eventos
            window.addEventListener('online', () => {
                syncManager.isOnline = true;
                syncManager.updateStatus();
                // tentar sincronizar imediatamente quando o navegador detectar online
                try { syncManager.trySync(); } catch (e) { console.warn('Erro ao iniciar sync on online event:', e); }
            });
            
            window.addEventListener('offline', () => {
                syncManager.isOnline = false;
                syncManager.updateStatus();
            });
            
            // Sincronizar storage entre abas/módulos
            window.addEventListener('storage', (event) => {
                if (event.key === 'financeiro-receber' || event.key === 'financeiro-pagar') {
                    console.log('Storage atualizado em outra aba:', event.key);
                    // Recarregar dados da aba
                    if (window.ui && window.ui.carregarDados) {
                        window.ui.carregarDados();
                    }
                }
            });
            
            // Configurar data padrão para primeira parcela (30 dias)
            const data30dias = new Date();

            // Tentar sincronizar automaticamente ao iniciar (caso o servidor local esteja disponível)
            try { syncManager.trySync(); } catch (e) { console.warn('Erro ao iniciar sync on startup:', e); }
            data30dias.setDate(data30dias.getDate() + 30);
            const dataPrimeiraParcela = document.getElementById('data-primeira-parcela');
            if (dataPrimeiraParcela) {
                dataPrimeiraParcela.value = data30dias.toISOString().split('T')[0];
            }
            
            // Configurar data padrão para primeira parcela de entrada (30 dias)
            const dataPrimeiraParcelaEntrada = document.getElementById('data-primeira-parcela-entrada');
            if (dataPrimeiraParcelaEntrada) {
                dataPrimeiraParcelaEntrada.value = data30dias.toISOString().split('T')[0];
            }
            
            // Configurar data padrão para vencimento de pagamento (30 dias)
            const vencimentoPagar = document.getElementById('vencimento-pagar');
            if (vencimentoPagar) {
                vencimentoPagar.value = data30dias.toISOString().split('T')[0];
            }
            
            // Fechar sugestões ao clicar fora
            document.addEventListener('click', (e) => {
                const sugestoes = document.getElementById('sugestoes-cliente');
                const buscarCliente = document.getElementById('buscar-cliente');
                if (sugestoes && buscarCliente && !sugestoes.contains(e.target) && e.target !== buscarCliente) {
                    sugestoes.style.display = 'none';
                }
            });

            // Filtro automático: aplicar ao digitar/alterar sem necessidade de clicar
            const filterClienteEl = document.getElementById('filter-cliente');
            const filterStatusEl = document.getElementById('filter-status-receber');
            const filterMesEl = document.getElementById('filter-mes');
            const filterAnoEl = document.getElementById('filter-ano');

            if (filterClienteEl) {
                let debounceTimerFilter;
                filterClienteEl.addEventListener('input', () => {
                    clearTimeout(debounceTimerFilter);
                    debounceTimerFilter = setTimeout(() => {
                        filtrarReceber();
                    }, 300);
                });
            }
            if (filterStatusEl) {
                filterStatusEl.addEventListener('change', () => filtrarReceber());
            }
            // Popular selects de mês (1-12) e ano (últimos 6 anos + ano atual + próximo ano)
            if (filterMesEl) {
                const monthNames = ["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"];
                for (let m = 1; m <= 12; m++) {
                    const opt = document.createElement('option');
                    opt.value = String(m).padStart(2,'0');
                    opt.textContent = monthNames[m-1];
                    filterMesEl.appendChild(opt);
                }
                filterMesEl.addEventListener('change', () => filtrarReceber());
            }

            if (filterAnoEl) {
                const now = new Date();
                const currentYear = now.getFullYear();
                const start = currentYear - 6; // 6 anos atrás
                const end = currentYear + 1; // próximo ano
                for (let y = start; y <= end; y++) {
                    const opt = document.createElement('option');
                    opt.value = String(y);
                    opt.textContent = String(y);
                    filterAnoEl.appendChild(opt);
                }
                filterAnoEl.addEventListener('change', () => filtrarReceber());
            }
        });

        // Funções de UI
        async function showSection(sectionId) {
            // Esconder todas as seções
            document.querySelectorAll('.dashboard').forEach(el => {
                el.classList.add('hidden');
            });
            
            // Mostrar seção selecionada
            document.getElementById(sectionId + '-section').classList.remove('hidden');
            
            // Atualizar menu ativo
            document.querySelectorAll('.nav-menu a').forEach(el => {
                el.classList.remove('active');
            });
            
            document.querySelector(`a[href="#${sectionId}"]`).classList.add('active');
            
            // Atualizar dados da seção
            if (sectionId === 'dashboard') {
                await ui.carregarDadosDashboard();
                // ATUALIZAR STATUS DOS VENCIMENTOS
                try { await ui.atualizarStatusVencimentosPersistente(); } catch (e) { console.warn('Erro ao atualizar status de vencimentos:', e); }
            } else if (sectionId === 'receber') {
                await ui.carregarReceber();
                // Aplicar filtro automaticamente ao abrir a seção de receber
                try { filtrarReceber(); } catch (e) { /* ignora se função não existir */ }
            } else if (sectionId === 'pagar') {
                await ui.carregarPagar();
            }
        }

        function showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
            
            // Configurar datas padrão
            if (modalId === 'modal-lancamento-receber') {
                const hoje = new Date();
                const data30dias = new Date();
                data30dias.setDate(hoje.getDate() + 30);
                
                const dataPrimeiraParcela = document.getElementById('data-primeira-parcela');
                if (dataPrimeiraParcela) {
                    dataPrimeiraParcela.value = data30dias.toISOString().split('T')[0];
                }
                
                const dataPrimeiraParcelaEntrada = document.getElementById('data-primeira-parcela-entrada');
                if (dataPrimeiraParcelaEntrada) {
                    dataPrimeiraParcelaEntrada.value = data30dias.toISOString().split('T')[0];
                }
                
                mudarTipoPagamento();
                
                // Se já houver um cliente selecionado, recarregar os orçamentos
                if (ui.clienteSelecionado) {
                    console.log('Recarregando orçamentos para cliente já selecionado:', ui.clienteSelecionado.id);
                    ui.carregarOrcamentosCliente(ui.clienteSelecionado.id);
                }
            }
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function showTab(tabId) {
            // Esconder todas as tabs
            document.querySelectorAll('.tab-content').forEach(el => {
                el.classList.remove('active');
            });
            
            document.querySelectorAll('.tab').forEach(el => {
                el.classList.remove('active');
            });
            
            // Mostrar tab selecionada
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        function showToast(mensagem, tipo = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${tipo}`;
            toast.innerHTML = `
                <i class="fas fa-${getIconeTipo(tipo)}"></i>
                <span>${mensagem}</span>
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function getIconeTipo(tipo) {
            switch(tipo) {
                case 'success': return 'check-circle';
                case 'error': return 'exclamation-circle';
                case 'warning': return 'exclamation-triangle';
                default: return 'info-circle';
            }
        }

        function mudarTipoPagamento() {
            const tipo = document.getElementById('tipo-pagamento').value;
            
            document.getElementById('campos-parcelado').classList.add('hidden');
            document.getElementById('campos-entrada').classList.add('hidden');
            document.getElementById('tabela-parcelas').classList.add('hidden');
            document.getElementById('tabela-entrada-parcelas').classList.add('hidden');
            
            if (tipo === 'parcelado') {
                document.getElementById('campos-parcelado').classList.remove('hidden');
                ui.calcularParcelas();
            } else if (tipo === 'entrada') {
                document.getElementById('campos-entrada').classList.remove('hidden');
                ui.calcularParcelas();
            }
        }

        function buscarCliente(nome) {
            ui.buscarCliente(nome);
        }
        
        function selecionarClientePorNome(nome) {
            ui.selecionarClientePorNome(nome);
        }

        function carregarDadosOrcamento(orcamentoId) {
            ui.carregarDadosOrcamento(orcamentoId);
        }

        function calcularParcelas() {
            ui.calcularParcelas();
        }

        function calcularParcelasEntrada() {
            ui.calcularParcelasEntrada();
        }

        function salvarRecebimento(event) {
            event.preventDefault();
            ui.salvarRecebimento();
        }

        function salvarPagamento(event) {
            event.preventDefault();
            ui.salvarPagamento();
        }

        function marcarComoPago() {
            if (ui.duplicataAtual) {
                ui.marcarComoPago(ui.duplicataAtual.id);
            }
        }

        function enviarWhatsApp() {
            if (ui.duplicataAtual && ui.clienteAtual) {
                const mensagem = whatsappManager.gerarMensagem(ui.clienteAtual, ui.duplicataAtual);
                document.getElementById('mensagem-whatsapp').value = mensagem;
                // armazenar telefone limpo para uso no abrirWhatsApp
                try {
                    ui.clienteAtual._telefoneParaWhats = whatsappManager.obterTelefoneCliente(ui.clienteAtual);
                } catch (e) {}
                showModal('modal-whatsapp');
            }
        }

        function abrirWhatsApp() {
            const mensagem = document.getElementById('mensagem-whatsapp').value;
            // tentar obter telefone limpo (prioriza campo _telefoneParaWhats, gerado ao abrir modal)
            let telefone = '';
            try {
                if (ui && ui.clienteAtual) {
                    telefone = ui.clienteAtual._telefoneParaWhats || ui.clienteAtual.whatsapp || ui.clienteAtual.telefone || '';
                }
            } catch (e) {
                telefone = '';
            }

            // limpar e validar
            telefone = whatsappManager.formatarTelefone(telefone);

            if (telefone && mensagem) {
                const link = whatsappManager.gerarLink(telefone, mensagem);
                window.open(link, '_blank');
                hideModal('modal-whatsapp');
                showToast('WhatsApp aberto com sucesso!', 'success');
            } else {
                showToast('Telefone ou mensagem inválidos', 'error');
            }
        }

        async function executarCleanupFinanceiro() {
            try {
                const beforeDate = document.getElementById('cleanup-before-date').value;
                const pass = document.getElementById('cleanup-admin-pass').value;
                const confirmText = document.getElementById('cleanup-confirm').value;

                if (!beforeDate) {
                    showToast('Informe a data limite (antes de)...', 'warning');
                    return;
                }
                if ((confirmText || '').trim().toUpperCase() !== 'DELETE') {
                    showToast('Digite DELETE para confirmar a exclusão', 'warning');
                    return;
                }

                // Mostrar loading
                const btn = document.querySelector('#modal-cleanup-financeiro .modal-footer .btn-danger');
                const prevText = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = 'Executando...';

                const headers = { 'Content-Type': 'application/json' };
                if (pass) headers['X-ADMIN-PASSWORD'] = pass;

                const resp = await fetch('/api/financeiro/cleanup', {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({ beforeDate, confirm: true })
                });

                const data = await resp.json();
                if (!resp.ok) {
                    console.error('Erro cleanup:', data);
                    showToast('Erro ao executar limpeza: ' + (data.error || resp.statusText), 'error');
                } else {
                    showToast('Limpeza executada. Registros removidos: ' + (data.deleted || 0), 'success');
                    // mostrar caminho do backup se disponível
                    if (data.backup) console.info('Backup salvo em:', data.backup);
                    hideModal('modal-cleanup-financeiro');
                    // Remover também localmente os registros: preferir IDs retornados pelo servidor (mais precisos),
                    // caso não haja `removedIds`, manter fallback por data.
                    try {
                        if (data && Array.isArray(data.removedItems) && data.removedItems.length > 0) {
                            // removedItems é array de { id, tipo }
                            for (const it of data.removedItems) {
                                if (!it || !it.id) continue;
                                const sid = String(it.id);
                                const tipo = (it.tipo || '').toLowerCase();
                                if (tipo === 'receber') {
                                    await ui.db.delete('receber', sid);
                                } else if (tipo === 'pagar') {
                                    await ui.db.delete('pagar', sid);
                                } else {
                                    // Tentar ambos stores por segurança
                                    await ui.db.delete('receber', sid);
                                    await ui.db.delete('pagar', sid);
                                }
                            }
                        } else if (data && Array.isArray(data.removedIds) && data.removedIds.length > 0) {
                            // Compatibilidade retroativa: apenas ids
                            const removedIds = data.removedIds.map(x => String(x));
                            const todosReceber = await ui.db.getAll('receber');
                            for (const r of todosReceber) if (r && removedIds.includes(String(r.id))) await ui.db.delete('receber', r.id);
                            const todosPagar = await ui.db.getAll('pagar');
                            for (const p of todosPagar) if (p && removedIds.includes(String(p.id))) await ui.db.delete('pagar', p.id);
                        } else {
                            // Fallback: remover por data (comportamento anterior)
                            const before = new Date(beforeDate);
                            // Receber
                            const todosReceber = await ui.db.getAll('receber');
                            for (const r of todosReceber) {
                                const venc = r.vencimento ? new Date(r.vencimento) : null;
                                if (venc && venc < before) {
                                    await ui.db.delete('receber', r.id);
                                }
                            }
                            // Pagar
                            const todosPagar = await ui.db.getAll('pagar');
                            for (const p of todosPagar) {
                                const venc2 = p.vencimento ? new Date(p.vencimento) : null;
                                if (venc2 && venc2 < before) {
                                    await ui.db.delete('pagar', p.id);
                                }
                            }
                        }
                    } catch (localErr) {
                        console.warn('Erro ao remover registros localmente após cleanup:', localErr);
                    }
                    // Recarregar tabelas
                    ui.carregarReceber();
                    ui.carregarPagar();
                }

                btn.disabled = false;
                btn.innerHTML = prevText;
            } catch (err) {
                console.error('Erro ao executar cleanup financeiro:', err);
                showToast('Erro ao executar limpeza', 'error');
            }
        }

        async function adminLogin() {
            try {
                const pass = document.getElementById('admin-pass-input').value;
                if (!pass) { showToast('Informe a senha', 'warning'); return; }
                const resp = await fetch('/api/admin/login', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: pass })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Login admin efetuado', 'success');
                    hideModal('modal-admin-login');
                    await checkAdminStatus();
                } else {
                    showToast('Falha no login: ' + (data.error || resp.statusText), 'error');
                }
            } catch (err) {
                console.error('Erro login admin:', err);
                showToast('Erro ao autenticar', 'error');
            }
        }

        async function filtrarReceber() {
            try {
                const clienteFiltro = (document.getElementById('filter-cliente').value || '').trim().toLowerCase();
                const statusFiltroRaw = (document.getElementById('filter-status-receber').value || '').trim();
                const statusFiltro = statusFiltroRaw ? statusFiltroRaw.toLowerCase() : '';

                const receber = await ui.db.getAll('receber');

                const hoje = new Date();

                const parseDate = (val) => {
                    if (!val && val !== 0) return null;
                    // Se for número (timestamp em ms ou s)
                    if (typeof val === 'number' || String(val).match(/^\d{10,13}$/)) {
                        const n = Number(val);
                        // se em segundos, converter para ms
                        const ms = n < 1e12 ? n * 1000 : n;
                        const dnum = new Date(ms);
                        if (!isNaN(dnum.getTime())) return dnum;
                    }
                    // tenta ISO/compatível
                    let d = new Date(val);
                    if (!isNaN(d.getTime())) return d;
                    // tenta dd/mm/yyyy
                    const m = String(val).match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                    if (m) return new Date(`${m[3]}-${m[2].padStart(2,'0')}-${m[1].padStart(2,'0')}`);
                    return null;
                };

                const isParceladoItem = (item) => {
                    if (!item) return false;
                    if (item.parcelado === true || item.parcelado === 'true' || item.parcelado === 1 || item.parcelado === '1') return true;
                    const tipo = (item.tipo || item.forma || '').toString().toLowerCase();
                    if (tipo === 'parcelado') return true;
                    const parcela = (item.parcela || item.parcela_de || item.numero_parcela || '');
                    const pstr = parcela.toString();
                    if (pstr && pstr.indexOf('/') !== -1) {
                        const parts = pstr.split('/').map(s => s.trim());
                        if (parts.length === 2 && parts[0] !== parts[1]) return true;
                    }
                    if ((Number(item.numParcelas) || Number(item.total_parcelas) || Number(item.totalParcelas) || 0) > 1) return true;
                    return false;
                };

                const getStatus = (item) => {
                    if (!item) return '';
                    let st = (item.status || item.situacao || item.estado || '') + '';
                    if (!st) {
                        // flags alternativos
                        if (item.pago === true || item.pago === 'true' || item.confirmado === 1 || item.confirmado === '1' || item.confirmadoEm || item.confirmado_em) st = 'pago';
                        if (item.aberto === true || item.aberto === 'true') st = st || 'aberto';
                    }
                    return st.toLowerCase();
                };

                const getClienteNome = (item) => {
                    return ((item.cliente || item.clienteNome || item.nome || item.cliente_nome || '') + '').toLowerCase();
                };

                // Leitura dos filtros de data (intervalo Início/Fim)
                const inicioFiltroRaw = (document.getElementById('filter-data-inicio') && document.getElementById('filter-data-inicio').value) || '';
                const fimFiltroRaw = (document.getElementById('filter-data-fim') && document.getElementById('filter-data-fim').value) || '';

                let inicioFiltroDate = inicioFiltroRaw ? new Date(inicioFiltroRaw) : null;
                let fimFiltroDate = fimFiltroRaw ? new Date(fimFiltroRaw) : null;
                if (fimFiltroDate) { fimFiltroDate.setHours(23,59,59,999); }

                const filtrados = receber.filter(item => {
                    // Filtrar por status
                    if (statusFiltro) {
                        if (statusFiltro === 'parcelado') {
                            if (!isParceladoItem(item)) return false;
                        } else if (statusFiltro === 'atrasado') {
                            const venc = parseDate(item.vencimento || item.data || item.created_at || item.criado_em);
                            if (!venc) return false;
                            const hojeZero = new Date(hoje.toISOString().split('T')[0] + 'T00:00:00');
                            if (!(venc < hojeZero)) return false;
                            if (getStatus(item) === 'pago') return false;
                        } else if (statusFiltro === 'aberto') {
                            // aceitar 'aberto' ou 'pendente' como abertos
                            const st = getStatus(item);
                            if (!(st === 'aberto' || st === 'pendente' || st === 'em aberto')) return false;
                            const venc = parseDate(item.vencimento || item.data);
                            if (venc) {
                                const hojeZero = new Date(hoje.toISOString().split('T')[0] + 'T00:00:00');
                                if (venc < hojeZero) return false;
                            }
                        } else {
                            // comparação flexível: aceita se o status contiver o filtro ou vice-versa
                            const st = getStatus(item);
                            if (!st) return false;
                            if (st !== statusFiltro && !st.includes(statusFiltro) && !statusFiltro.includes(st)) return false;
                        }
                    }

                        // Filtrar por nome do cliente se informado
                        if (clienteFiltro) {
                            const nomeCliente = getClienteNome(item);
                            if (!nomeCliente || !nomeCliente.includes(clienteFiltro)) return false;
                        }

                        // Filtrar por mês e ano selecionados
                        const filtroMesVal = (document.getElementById('filter-mes') && document.getElementById('filter-mes').value) || '';
                        const filtroAnoVal = (document.getElementById('filter-ano') && document.getElementById('filter-ano').value) || '';
                        if (filtroMesVal || filtroAnoVal) {
                            const venc = parseDate(item.vencimento || item.data || item.created_at || item.criado_em);
                            if (!venc) return false;
                            if (filtroMesVal) {
                                const mnum = Number(filtroMesVal);
                                if ((venc.getMonth() + 1) !== mnum) return false;
                            }
                            if (filtroAnoVal) {
                                const ynum = Number(filtroAnoVal);
                                if (venc.getFullYear() !== ynum) return false;
                            }
                        }

                    // Filtrar por intervalo de datas (vencimento)
                    if (inicioFiltroDate || fimFiltroDate) {
                        const venc = parseDate(item.vencimento || item.data || item.created_at || item.criado_em);
                        // Filtro por intervalo (data início/fim): incluir itens sem data também
                        if (venc) {
                            if (inicioFiltroDate && venc < inicioFiltroDate) return false;
                            if (fimFiltroDate && venc > fimFiltroDate) return false;
                        } else {
                            // sem data: manter
                        }
                    }

                    return true;
                });

                const tabela = document.getElementById('tabela-receber');
                let html = '';

                // carregar lista de clientes para resolver nomes
                const _clientesList = (ui && ui.db && typeof ui.db.getAllSync === 'function') ? ui.db.getAllSync('clientes') || [] : (localStorage.getItem('clientes') ? JSON.parse(localStorage.getItem('clientes')||'[]') : []);

                const resolveClienteNome = (it) => {
                    if (!it) return '—';
                    // se item.cliente for objeto
                    const c = it.cliente;
                    if (c && typeof c === 'object') {
                        return c.nome || c.nomeFantasia || c.nome_completo || c.razao || c.nome || String(c.id) || '—';
                    }
                    // se item.cliente for string não vazia — pode já ser o nome
                    if (c && typeof c === 'string' && c.trim() !== '') return c;
                    // tentar campos alternativos
                    if (it.clienteNome && it.clienteNome.trim()) return it.clienteNome;
                    if (it.nome && it.nome.trim()) return it.nome;
                    // procurar por clienteId/cliente_id
                    const cid = it.clienteId || it.cliente_id || it.cliente_id_fk || null;
                    if (cid) {
                        const found = _clientesList.find(x => String(x.id) === String(cid) || String(x.id) === String(it.cliente));
                        if (found) return found.nome || found.nomeFantasia || found.nome_completo || found.razao || String(found.id);
                    }
                    // fallback: se item.cliente aparenta ser id mas não encontrado, mostrar id
                    if (c) return String(c);
                    return '—';
                };

                filtrados.forEach(item => {
                    const valorFormatado = ui.formatarMoeda(item.valor || 0);
                    const nomeCliente = resolveClienteNome(item);
                    html += `
                        <tr>
                            <td>${nomeCliente}</td>
                            <td>${item.descricao}</td>
                            <td>${item.parcela || '1/1'}</td>
                            <td>${valorFormatado}</td>
                            <td>${ui.formatarData(item.vencimento)}</td>
                            <td>${ui.criarBadgeStatus(item.status)}</td>
                            <td>
                                <button class="btn btn-success btn-sm" onclick="ui.marcarComoPago('${item.id}')">
                                    <i class="fas fa-check"></i>
                                </button>
                                <button class="btn btn-whatsapp btn-sm" onclick="ui.enviarWhatsAppDuplicata('${item.id}')">
                                    <i class="fab fa-whatsapp"></i>
                                </button>
                            </td>
                        </tr>
                    `;
                });

                tabela.innerHTML = html || '<tr><td colspan="7" class="text-center">Nenhuma conta a receber</td></tr>';

                showToast('Filtro aplicado', 'info');
                // Atualizar visibilidade do botão de cleanup (caso login admin tenha mudado)
                try { await checkAdminStatus(); } catch(e) { /* ignore */ }
            } catch (error) {
                console.error('Erro ao aplicar filtro de receber:', error);
                showToast('Erro ao aplicar filtro', 'error');
            }
        }

        async function checkAdminStatus() {
            try {
                const resp = await fetch('/api/admin/status');
                const data = await resp.json();
                const container = document.getElementById('cleanup-btn-container');
                if (data && data.isAdmin) {
                    container.style.display = '';
                } else {
                    container.style.display = 'none';
                }
                return data;
            } catch (err) {
                console.warn('Erro ao verificar status admin:', err);
                return { isAdmin: false };
            }
        }

        async function gerarRelatorio(tipo) {
            try {
                const inicio = document.getElementById('rel-data-inicio').value;
                const fim = document.getElementById('rel-data-fim').value;
                const status = document.getElementById('rel-status').value;

                let items = [];
                let title = '';

                if (tipo === 'duplicatas') {
                    items = await ui.db.getAll('receber');
                    title = 'Duplicatas Parceladas / Receber';
                } else if (tipo === 'pagar') {
                    items = await ui.db.getAll('pagar');
                    title = 'Contas a Pagar';
                } else {
                    items = [];
                }

                // Filtrar por intervalo de datas (vencimento) e status
                const inicioISO = inicio ? new Date(inicio).toISOString().split('T')[0] : null;
                const fimISO = fim ? new Date(fim).toISOString().split('T')[0] : null;

                const clientes = await ui.db.getAll('clientes');

                const parseDate = (val) => {
                    if (!val && val !== 0) return null;
                    if (typeof val === 'number' || String(val).match(/^\d{10,13}$/)) {
                        const n = Number(val);
                        const ms = n < 1e12 ? n * 1000 : n;
                        const dnum = new Date(ms);
                        if (!isNaN(dnum.getTime())) return dnum;
                    }
                    let d = new Date(val);
                    if (!isNaN(d.getTime())) return d;
                    const m = String(val).match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                    if (m) return new Date(`${m[3]}-${m[2].padStart(2,'0')}-${m[1].padStart(2,'0')}`);
                    return null;
                };

                const isParceladoItem = (item) => {
                    if (!item) return false;
                    if (item.parcelado === true || item.parcelado === 'true' || item.parcelado === 1 || item.parcelado === '1') return true;
                    const tipo = (item.tipo || item.forma || '').toString().toLowerCase();
                    if (tipo === 'parcelado') return true;
                    const parcela = (item.parcela || item.parcela_de || item.numero_parcela || '');
                    const pstr = parcela.toString();
                    if (pstr && pstr.indexOf('/') !== -1) {
                        const parts = pstr.split('/').map(s => s.trim());
                        if (parts.length === 2 && parts[0] !== parts[1]) return true;
                    }
                    if ((Number(item.numParcelas) || Number(item.total_parcelas) || Number(item.totalParcelas) || 0) > 1) return true;
                    return false;
                };

                const getStatus = (item) => {
                    if (!item) return '';
                    let st = (item.status || item.situacao || item.estado || '') + '';
                    if (!st) {
                        if (item.pago === true || item.pago === 'true' || item.confirmado === 1 || item.confirmado === '1' || item.confirmadoEm || item.confirmado_em) st = 'pago';
                        if (item.aberto === true || item.aberto === 'true') st = st || 'aberto';
                    }
                    return st.toLowerCase();
                };

                const filtrados = items.filter(item => {
                    if (status && status.toLowerCase() !== 'todos') {
                        const st = getStatus(item);
                        const s = status.toLowerCase();
                        if (s === 'parcelado') {
                            if (!isParceladoItem(item)) return false;
                        } else if (s === 'atrasado') {
                            const venc = parseDate(item.vencimento || item.data || item.created_at || item.criado_em);
                            if (!venc) return false;
                            const hojeZero = new Date(new Date().toISOString().split('T')[0] + 'T00:00:00');
                            if (!(venc < hojeZero)) return false;
                            if (st === 'pago') return false;
                        } else if (s === 'aberto') {
                            if (!(st === 'aberto' || st === 'pendente' || st === 'em aberto')) return false;
                        } else {
                            if (!st) return false;
                            if (st !== s && !st.includes(s) && !s.includes(st)) return false;
                        }
                    }

                    if (inicioISO || fimISO) {
                        const venc = (item.vencimento ? (item.vencimento.split ? item.vencimento.split('T')[0] : item.vencimento) : null) || null;
                        const vencDate = venc ? parseDate(venc) : null;
                        if (!vencDate) return false;
                        if (inicioISO && vencDate.toISOString().split('T')[0] < inicioISO) return false;
                        if (fimISO && vencDate.toISOString().split('T')[0] > fimISO) return false;
                    }

                    return true;
                });

                // Construir HTML do relatório
                const container = document.getElementById('tabela-relatorio');
                let html = '';

                html += `
                    <div class="d-flex justify-between align-center mb-10">
                        <h4>${title}</h4>
                        <div>
                            <button class="btn btn-primary" onclick="imprimirRelatorio()"><i class="fas fa-print"></i> Imprimir</button>
                        </div>
                    </div>
                `;

                html += `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Cliente / Fornecedor</th>
                                <th>Descrição</th>
                                <th>Parcela</th>
                                <th>Valor</th>
                                <th>Vencimento</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                let total = 0;
                filtrados.forEach(item => {
                    // Resolver nome do cliente/fornecedor a partir dos dados locais
                    let nome = '-';
                    try {
                        const clienteId = item.clienteId || item.cliente_id || item.cliente;
                        if (clienteId) {
                            const cli = clientes.find(c => String(c.id) === String(clienteId));
                            if (cli && cli.nome) nome = cli.nome;
                        } else if (item.fornecedor) {
                            nome = item.fornecedor;
                        }
                    } catch (e) {
                        nome = item.cliente || item.fornecedor || '-';
                    }
                    const desc = item.descricao || '-';
                    const parcela = item.parcela || '1/1';
                    const valor = item.valor ? parseFloat(item.valor) : 0;
                    total += valor;
                    const venc = item.vencimento ? new Date(item.vencimento).toLocaleDateString('pt-BR') : '-';
                    const statusBadge = ui.criarBadgeStatus(item);

                    html += `
                        <tr>
                            <td>${nome}</td>
                            <td>${desc}</td>
                            <td>${parcela}</td>
                            <td>${ui.formatarMoeda(valor)}</td>
                            <td>${venc}</td>
                            <td>${statusBadge}</td>
                        </tr>
                    `;
                });

                html += `
                        </tbody>
                        <tfoot>
                            <tr>
                                <td colspan="3"><strong>Total</strong></td>
                                <td><strong>${ui.formatarMoeda(total)}</strong></td>
                                <td colspan="2"></td>
                            </tr>
                        </tfoot>
                    </table>
                `;

                container.innerHTML = html;
                showToast('Relatório carregado na tela', 'success');

            } catch (error) {
                console.error('Erro ao gerar relatório:', error);
                showToast('Erro ao gerar relatório', 'error');
            }
        }

        function imprimirRelatorio() {
            const content = document.getElementById('tabela-relatorio').innerHTML;
            const estilo = `
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; }
                    .data-table { width: 100%; border-collapse: collapse; }
                    .data-table th, .data-table td { padding: 8px; border: 1px solid #ddd; text-align: left; }
                    .data-table thead { background: #f8f9fa; }
                </style>
            `;
            const win = window.open('', '_blank');
            win.document.write(`<html><head><title>Relatório</title>${estilo}</head><body>${content}</body></html>`);
            win.document.close();
            win.focus();
            // Aguardar um pouco para garantir que o conteúdo foi carregado
            setTimeout(() => { win.print(); }, 300);
        }

        // Inicializar sync status
        syncManager.updateStatus();
    </script>
        <!-- Air Datepicker JS removed (month selector not used) -->



</body>
</html>